<!doctype html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <meta name="generator" content="VuePress 2.0.0-rc.14" />
    <style>
      :root {
        --c-bg: #fff;
      }

      html.dark {
        --c-bg: #22272e;
      }

      html,
      body {
        background-color: var(--c-bg);
      }
    </style>
    <script>
      const userMode = localStorage.getItem('vuepress-color-scheme')
      const systemDarkMode =
        window.matchMedia &&
        window.matchMedia('(prefers-color-scheme: dark)').matches
      if (userMode === 'dark' || (userMode !== 'light' && systemDarkMode)) {
        document.documentElement.classList.toggle('dark', true)
      }
    </script>
    <link rel="icon" href="favicon.ico"><title>6.Redis | TuTOU123com</title><meta name="description" content="繁星似海 熠熠生辉">
    <link rel="stylesheet" href="/assets/css/styles.64e5b71f.css">
    <link rel="preload" href="/assets/js/runtime~app.bdc11503.js" as="script"><link rel="preload" href="/assets/css/styles.64e5b71f.css" as="style"><link rel="preload" href="/assets/js/639.c6a90640.js" as="script"><link rel="preload" href="/assets/js/app.69d07200.js" as="script">
    <link rel="prefetch" href="/assets/js/js_6.Redis.html.942045f4.js" as="script"><link rel="prefetch" href="/assets/js/js_4.MySQL.html.9af022bc.js" as="script"><link rel="prefetch" href="/assets/js/js_7.serve.html.777d3ebf.js" as="script"><link rel="prefetch" href="/assets/js/js_date.html.a3621596.js" as="script"><link rel="prefetch" href="/assets/js/js_other.html.372a0f44.js" as="script"><link rel="prefetch" href="/assets/js/js_5.line.html.6dd5da13.js" as="script"><link rel="prefetch" href="/assets/js/js_3. collet.html.e7e1b03d.js" as="script"><link rel="prefetch" href="/assets/js/about.html.66b308d0.js" as="script"><link rel="prefetch" href="/assets/js/js_index.html.b94d2523.js" as="script"><link rel="prefetch" href="/assets/js/index.html.af5720d6.js" as="script"><link rel="prefetch" href="/assets/js/get-started.html.ea845282.js" as="script"><link rel="prefetch" href="/assets/js/404.html.0b487de8.js" as="script">
  </head>
  <body>
    <div id="app"><!--[--><div class="vp-theme-container external-link-icon"><!--[--><header class="vp-navbar"><div class="vp-toggle-sidebar-button" title="toggle sidebar" aria-expanded="false" role="button" tabindex="0"><div class="icon" aria-hidden="true"><span></span><span></span><span></span></div></div><span><a class="route-link" href="/"><img class="vp-site-logo" src="https://vuejs.press/images/hero.png" alt="TuTOU123com"><span class="vp-site-name vp-hide-mobile" aria-hidden="true">TuTOU123com</span></a></span><div class="vp-navbar-items-wrapper" style=""><!--[--><!--]--><nav class="vp-navbar-items vp-hide-mobile" aria-label="site navigation"><!--[--><div class="vp-navbar-item"><a class="route-link route-link-active auto-link" href="/" aria-label="主页"><!---->主页<!----></a></div><div class="vp-navbar-item"><div class="vp-navbar-dropdown-wrapper"><button class="vp-navbar-dropdown-title" type="button" aria-label="学习"><span class="title">学习</span><span class="arrow down"></span></button><button class="vp-navbar-dropdown-title-mobile" type="button" aria-label="学习"><span class="title">学习</span><span class="right arrow"></span></button><ul style="display:none;" class="vp-navbar-dropdown"><!--[--><li class="vp-navbar-dropdown-item"><!--[--><h4 class="vp-navbar-dropdown-subtitle"><span>后端</span></h4><ul class="vp-navbar-dropdown-subitem-wrapper"><!--[--><li class="vp-navbar-dropdown-subitem"><a class="route-link route-link-active auto-link" href="/js/" aria-label="八股文"><!---->八股文<!----></a></li><li class="vp-navbar-dropdown-subitem"><a class="auto-link external-link" href="https://blog.csdn.net/leader_song" aria-label="博客" rel="noopener noreferrer" target="_blank"><!---->博客<!----></a></li><!--]--></ul><!--]--></li><li class="vp-navbar-dropdown-item"><!--[--><h4 class="vp-navbar-dropdown-subtitle"><span>网站</span></h4><ul class="vp-navbar-dropdown-subitem-wrapper"><!--[--><li class="vp-navbar-dropdown-subitem"><a class="auto-link external-link" href="https://code.iglooblog.top/html/1.html" aria-label="Java" rel="noopener noreferrer" target="_blank"><!---->Java<!----></a></li><li class="vp-navbar-dropdown-subitem"><a class="auto-link external-link" href="https://1m29yg5p67.k.topthink.com/@markdown" aria-label="SpringCloud" rel="noopener noreferrer" target="_blank"><!---->SpringCloud<!----></a></li><li class="vp-navbar-dropdown-subitem"><a class="auto-link external-link" href="https://code.iglooblog.top/css/1.html" aria-label="Gitee" rel="noopener noreferrer" target="_blank"><!---->Gitee<!----></a></li><!--]--></ul><!--]--></li><!--]--></ul></div></div><div class="vp-navbar-item"><div class="vp-navbar-dropdown-wrapper"><button class="vp-navbar-dropdown-title" type="button" aria-label="工具"><span class="title">工具</span><span class="arrow down"></span></button><button class="vp-navbar-dropdown-title-mobile" type="button" aria-label="工具"><span class="title">工具</span><span class="right arrow"></span></button><ul style="display:none;" class="vp-navbar-dropdown"><!--[--><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/politics.html" aria-label="windows"><!---->windows<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/english.html" aria-label="mac"><!---->mac<!----></a></li><!--]--></ul></div></div><div class="vp-navbar-item"><div class="vp-navbar-dropdown-wrapper"><button class="vp-navbar-dropdown-title" type="button" aria-label="知识星球"><span class="title">知识星球</span><span class="arrow down"></span></button><button class="vp-navbar-dropdown-title-mobile" type="button" aria-label="知识星球"><span class="title">知识星球</span><span class="right arrow"></span></button><ul style="display:none;" class="vp-navbar-dropdown"><!--[--><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/politics.html" aria-label="星球地址"><!---->星球地址<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/english.html" aria-label="星球精华"><!---->星球精华<!----></a></li><!--]--></ul></div></div><div class="vp-navbar-item"><a class="route-link auto-link" href="/about.html" aria-label="关于"><!---->关于<!----></a></div><div class="vp-navbar-item"><div class="vp-navbar-dropdown-wrapper"><button class="vp-navbar-dropdown-title" type="button" aria-label="Select language"><span class="title">选择语言</span><span class="arrow down"></span></button><button class="vp-navbar-dropdown-title-mobile" type="button" aria-label="Select language"><span class="title">选择语言</span><span class="right arrow"></span></button><ul style="display:none;" class="vp-navbar-dropdown"><!--[--><li class="vp-navbar-dropdown-item"><a class="route-link route-link-active auto-link" href="/js/6.Redis.html" aria-label="简体中文"><!---->简体中文<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/en/" aria-label="English"><!---->English<!----></a></li><!--]--></ul></div></div><div class="vp-navbar-item"><a class="auto-link external-link" href="https://github.com/leaderrSong/min" aria-label="GitHub" rel="noopener noreferrer" target="_blank"><!---->GitHub<!----></a></div><!--]--></nav><!--[--><!--]--><button class="vp-toggle-color-mode-button" title="toggle color mode"><svg class="light-icon" viewbox="0 0 32 32" style=""><path d="M16 12.005a4 4 0 1 1-4 4a4.005 4.005 0 0 1 4-4m0-2a6 6 0 1 0 6 6a6 6 0 0 0-6-6z" fill="currentColor"></path><path d="M5.394 6.813l1.414-1.415l3.506 3.506L8.9 10.318z" fill="currentColor"></path><path d="M2 15.005h5v2H2z" fill="currentColor"></path><path d="M5.394 25.197L8.9 21.691l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 25.005h2v5h-2z" fill="currentColor"></path><path d="M21.687 23.106l1.414-1.415l3.506 3.506l-1.414 1.414z" fill="currentColor"></path><path d="M25 15.005h5v2h-5z" fill="currentColor"></path><path d="M21.687 8.904l3.506-3.506l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 2.005h2v5h-2z" fill="currentColor"></path></svg><svg class="dark-icon" viewbox="0 0 32 32" style="display:none;"><path d="M13.502 5.414a15.075 15.075 0 0 0 11.594 18.194a11.113 11.113 0 0 1-7.975 3.39c-.138 0-.278.005-.418 0a11.094 11.094 0 0 1-3.2-21.584M14.98 3a1.002 1.002 0 0 0-.175.016a13.096 13.096 0 0 0 1.825 25.981c.164.006.328 0 .49 0a13.072 13.072 0 0 0 10.703-5.555a1.01 1.01 0 0 0-.783-1.565A13.08 13.08 0 0 1 15.89 4.38A1.015 1.015 0 0 0 14.98 3z" fill="currentColor"></path></svg></button><!----></div></header><!--]--><div class="vp-sidebar-mask"></div><!--[--><aside class="vp-sidebar"><nav class="vp-navbar-items" aria-label="site navigation"><!--[--><div class="vp-navbar-item"><a class="route-link route-link-active auto-link" href="/" aria-label="主页"><!---->主页<!----></a></div><div class="vp-navbar-item"><div class="vp-navbar-dropdown-wrapper"><button class="vp-navbar-dropdown-title" type="button" aria-label="学习"><span class="title">学习</span><span class="arrow down"></span></button><button class="vp-navbar-dropdown-title-mobile" type="button" aria-label="学习"><span class="title">学习</span><span class="right arrow"></span></button><ul style="display:none;" class="vp-navbar-dropdown"><!--[--><li class="vp-navbar-dropdown-item"><!--[--><h4 class="vp-navbar-dropdown-subtitle"><span>后端</span></h4><ul class="vp-navbar-dropdown-subitem-wrapper"><!--[--><li class="vp-navbar-dropdown-subitem"><a class="route-link route-link-active auto-link" href="/js/" aria-label="八股文"><!---->八股文<!----></a></li><li class="vp-navbar-dropdown-subitem"><a class="auto-link external-link" href="https://blog.csdn.net/leader_song" aria-label="博客" rel="noopener noreferrer" target="_blank"><!---->博客<!----></a></li><!--]--></ul><!--]--></li><li class="vp-navbar-dropdown-item"><!--[--><h4 class="vp-navbar-dropdown-subtitle"><span>网站</span></h4><ul class="vp-navbar-dropdown-subitem-wrapper"><!--[--><li class="vp-navbar-dropdown-subitem"><a class="auto-link external-link" href="https://code.iglooblog.top/html/1.html" aria-label="Java" rel="noopener noreferrer" target="_blank"><!---->Java<!----></a></li><li class="vp-navbar-dropdown-subitem"><a class="auto-link external-link" href="https://1m29yg5p67.k.topthink.com/@markdown" aria-label="SpringCloud" rel="noopener noreferrer" target="_blank"><!---->SpringCloud<!----></a></li><li class="vp-navbar-dropdown-subitem"><a class="auto-link external-link" href="https://code.iglooblog.top/css/1.html" aria-label="Gitee" rel="noopener noreferrer" target="_blank"><!---->Gitee<!----></a></li><!--]--></ul><!--]--></li><!--]--></ul></div></div><div class="vp-navbar-item"><div class="vp-navbar-dropdown-wrapper"><button class="vp-navbar-dropdown-title" type="button" aria-label="工具"><span class="title">工具</span><span class="arrow down"></span></button><button class="vp-navbar-dropdown-title-mobile" type="button" aria-label="工具"><span class="title">工具</span><span class="right arrow"></span></button><ul style="display:none;" class="vp-navbar-dropdown"><!--[--><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/politics.html" aria-label="windows"><!---->windows<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/english.html" aria-label="mac"><!---->mac<!----></a></li><!--]--></ul></div></div><div class="vp-navbar-item"><div class="vp-navbar-dropdown-wrapper"><button class="vp-navbar-dropdown-title" type="button" aria-label="知识星球"><span class="title">知识星球</span><span class="arrow down"></span></button><button class="vp-navbar-dropdown-title-mobile" type="button" aria-label="知识星球"><span class="title">知识星球</span><span class="right arrow"></span></button><ul style="display:none;" class="vp-navbar-dropdown"><!--[--><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/politics.html" aria-label="星球地址"><!---->星球地址<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/english.html" aria-label="星球精华"><!---->星球精华<!----></a></li><!--]--></ul></div></div><div class="vp-navbar-item"><a class="route-link auto-link" href="/about.html" aria-label="关于"><!---->关于<!----></a></div><div class="vp-navbar-item"><div class="vp-navbar-dropdown-wrapper"><button class="vp-navbar-dropdown-title" type="button" aria-label="Select language"><span class="title">选择语言</span><span class="arrow down"></span></button><button class="vp-navbar-dropdown-title-mobile" type="button" aria-label="Select language"><span class="title">选择语言</span><span class="right arrow"></span></button><ul style="display:none;" class="vp-navbar-dropdown"><!--[--><li class="vp-navbar-dropdown-item"><a class="route-link route-link-active auto-link" href="/js/6.Redis.html" aria-label="简体中文"><!---->简体中文<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/en/" aria-label="English"><!---->English<!----></a></li><!--]--></ul></div></div><div class="vp-navbar-item"><a class="auto-link external-link" href="https://github.com/leaderrSong/min" aria-label="GitHub" rel="noopener noreferrer" target="_blank"><!---->GitHub<!----></a></div><!--]--></nav><!--[--><!--]--><ul class="vp-sidebar-items"><!--[--><li><p tabindex="0" class="vp-sidebar-item vp-sidebar-heading active collapsible">目录 <span class="down arrow"></span></p><ul style="" class="vp-sidebar-children"><!--[--><li><a class="route-link auto-link vp-sidebar-item" href="/js/date.html" aria-label="1.数据结构"><!---->1.数据结构<!----></a><!----></li><li><a class="auto-link external-link vp-sidebar-item" href="https://www.runoob.com/java/java-basic-syntax.html" aria-label="2.java基础" rel="noopener noreferrer" target="_blank"><!---->2.java基础<!----></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/js/3.%20collet.html" aria-label="3.集合"><!---->3.集合<!----></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/js/3.%20collet.html" aria-label="3.集合"><!---->3.集合<!----></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/js/4.MySQL.html" aria-label="4.Mysql"><!---->4.Mysql<!----></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/js/5.line.html" aria-label="5.多线程"><!---->5.多线程<!----></a><!----></li><li><a class="route-link route-link-active auto-link vp-sidebar-item active" href="/js/6.Redis.html" aria-label="6.Redis"><!---->6.Redis<!----></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/js/7.serve.html" aria-label="7.微服务架构"><!---->7.微服务架构<!----></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/js/other.html" aria-label="8.Git+Maven+Jwt+Nginx"><!---->8.Git+Maven+Jwt+Nginx<!----></a><!----></li><!--]--></ul></li><!--]--></ul><!--[--><!--]--></aside><!--]--><!--[--><main class="vp-page"><!--[--><!--]--><div class="theme-default-content"><!--[--><!--]--><div><h1 id="_6-redis" tabindex="-1"><a class="header-anchor" href="#_6-redis"><span>6.Redis</span></a></h1><h2 id="_01-redis-的存储结构有哪些" tabindex="-1"><a class="header-anchor" href="#_01-redis-的存储结构有哪些"><span>01.Redis 的存储结构有哪些</span></a></h2><p>五大数据类型 1、String，字符串，是 redis 的最基本的类型，一个 key 对应一个 value。是二进制安全的，最大能存储 512MB。 2、Hash，散列，是一个键值(key=&gt;value)对集合。string 类型的 field 和value 的映射表，特别适合用于存储对象。每个 hash 可以存储 232 -1 键值对（40 多亿） 2、List，列表，是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列边或者尾部 （右边）。最多可存储 232 - 1 元素(4294967295, 每个列表可存储 40 亿) 3、Set，集合， 是 string 类型的无序集合，最大的成员数为 232 -1(4294967295, 每个集合可存储 40 多亿个成员)。 4、Sorted set，有序集合，和 set 一样也是 string 类型元素的集合,且不允许重复的成员。 不同的是每个元素都会关联一个 double 类型的分数。redis 正是通过分数来为集合中的成员进行从小到大的排序。zset 的成员是唯一的,但分数(score)却可以重复。 三种特殊类型【了解】 1、HyperLogLog 基数统计算法 什么是基数？(不重复的数据元素的个数)，比如数据集 {1, 3, 5, 7, 5, 7, 8}， 那么这个数据集的基数集为 {1, 3, 5 ,7, 8}, 基数(不重复元素)为5。 基数估计就是在误差可接受的范围内，快速计算基数 2、Geospatial 地理位置 Redis GEO 主要用于存储地理位置信息，并对存储的信息进行操作，该功能在 Redis 3.2 版本新增3、BitMaps (位图) 位图一般由二进制0，1表示，常用来显示两种状态。例如：打卡，未打卡。迟到，未迟到 如果你是 Redis 高端玩家，你可能玩过 Redis Module ，可以再加上下面几种数据结构： BloomFilter RedisSearch Redis-ML JSON 另外，在 Redis 5.0 增加了 Stream 功能，一个新的强大的支持多播的可持久化的消息队列，提供类似 Kafka 的功能</p><h2 id="_02-为什么要用-redis" tabindex="-1"><a class="header-anchor" href="#_02-为什么要用-redis"><span>02.为什么要用 Redis</span></a></h2><p>redis优点： 1 因为是纯内存操作，Redis 的性能非常出色，每秒可以处理超过 10 万次读写操作，是已知性能最快的 Key- Value 数据库。Redis 支持事务 、持久化 2、单线程操作，避免了频繁的上下文切换。 3、采用了非阻塞 I/O 多路复用机制。I/O 多路复用就是只有单个线程，通过跟踪每个 I/O 流的状态，来管理 多个 I/O 流。 高性能： 假如用户第一次访问数据库中的某些数据。这个过程会比较慢，因为是从硬盘上读取的。将该用户访问 的数据存在数缓存中，这样下一次再访问这些数据的时候就可以直接从缓存中获取了。操作缓存就是直 接操作内存，所以速度相当快。如果数据库中的对应数据改变的之后，同步改变缓存中相应的数据即可！Redis使用场景 数据缓存 会话缓存 时效性数据 访问频率 计数器 社交列表 记录用户判定信息 交集、并集和差集 热门列表与排行榜 最新动态 消息队列 分布式锁 <img src="https://cdn.nlark.com/yuque/0/2022/png/29328785/1660639736615-27a914ec-f391-4012-ac8d-4f83f999c187.png#averageHue=%23f7f7f7&amp;clientId=ud4875bf3-7675-4&amp;from=paste&amp;height=438&amp;id=u51a699c7&amp;originHeight=547&amp;originWidth=1002&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=131152&amp;status=done&amp;style=none&amp;taskId=u7a53281e-f2e7-4656-980b-040191a0343&amp;title=&amp;width=801.6#averageHue=%23f7f7f7&amp;id=sLmGi&amp;originHeight=547&amp;originWidth=1002&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none#averageHue=%23f7f7f7&amp;from=url&amp;id=jhyID&amp;originHeight=547&amp;originWidth=1002&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt="">高并发： 直接操作缓存能够承受的请求是远远大于直接访问数据库的，所以我们可以考虑把数据库中的部分数据转 移到缓存中去，这样用户的一部分请求会直接到缓存这里而不用经过数据库。</p><h2 id="_03-redis的持久化-aof-rdb" tabindex="-1"><a class="header-anchor" href="#_03-redis的持久化-aof-rdb"><span>03.redis的持久化(AOF RDB)</span></a></h2><p>redis有两种持久化方式，aof和rdb，aof相当于日志记录操作命令，rdb相当于数据的快照。安全性来讲由于aof的记录能够精确到秒级追加甚至逐条追加，而rdb只能是全量复制，aof明显高于rdb。但是从性能来讲rdb就略胜一筹，rdb是redis性能最大化的体现，它不用每秒监控是否有数据写入，当达到触发条件后就自动fork一个子进程进行全量更新，速度也很快。容灾回复方面rdb更是能够快速的恢复数据，而aof需要读取再写入，相对慢了很多。Redis 提供了两种持久化的方式，分别是 RDB（Redis DataBase）和 AOF（Append Only File）。 RDB，简而言之，就是在不同的时间点，将 redis 存储的数据生成快照并存储到磁盘等介质上。 AOF，则是换了一个角度来实现持久化，那就是将 redis 执行过的所有写指令记录下来，在下次 redis 重新启动时，只要把这些写指令从前到后再重复执行一遍，就可以实现数据恢复了。 RDB 和 AOF 两种方式也可以同时使用，在这种情况下，如果 redis 重启的话，则会优先采用 AOF 方 式来进行数据恢复，这是因为 AOF 方式的数据恢复完整度更高</p><h2 id="_04-缓存和数据库双写一致性问题" tabindex="-1"><a class="header-anchor" href="#_04-缓存和数据库双写一致性问题"><span>04.缓存和数据库双写一致性问题</span></a></h2><p>一致性的问题很常见，因为加入了缓存之后，请求是先从 redis中查询，如果 redis 中存在数据就不 会走数据库了，如果不能保证缓存跟数据库的一致性就会导致请求获取到的数据不是最新的数据。 解决方案： 1、编写删除缓存的接口，在更新数据库的同时，调用删除缓存 的接口删除缓存中的数据。这么做会有耦合高以及调用接口失败的情况。 2、消息队列：ActiveMQ，消息通知。</p><h2 id="_05-缓存雪崩问题" tabindex="-1"><a class="header-anchor" href="#_05-缓存雪崩问题"><span>05.缓存雪崩问题</span></a></h2><p>大量的热点 key 设置了相同的过期时间，导在缓存在同一时刻全部失效，造成瞬时数据库请求量大、压力骤增，引起雪崩，甚至导致数据库被打挂。缓存雪崩其实有点像“升级版的缓存击穿”，缓存击穿是一个热点 key，缓存雪崩是一组热点 key。 解决方案： 过期时间打散：缓存数据的过期时间设置随机，防止同一时间大量数据过期现象发生。缓存分布式部署：如果缓存数据库是分布式部署，将热点数据均匀分布在不同的缓存数据库中。热点数据不过期：设置热点数据永远不过期。加互斥锁：该方式和缓存击穿一样，按 key 维度加锁，对于同一个 key，只允许一个线程去计算，其他线程原地阻塞等待第一个线程的计算结果，然后直接走缓存即可。</p><h2 id="_06-缓存穿透" tabindex="-1"><a class="header-anchor" href="#_06-缓存穿透"><span>06.缓存穿透</span></a></h2><p>缓存穿透是指 缓存和数据库中都没有的数据，而用户不断发起请求，请求会直接打到数据库上，并且查不到数据，没法写缓存，所以下一次同样会打到数据库上。此时，缓存起不到作用，请求每次都会走到数据库，流量大时数据库可能会被打挂。此时缓存就好像被“穿透”了一样，起不到任何作用。在流量大时，可能 DB 就挂掉了，要是有人利用不存在的 key 频繁攻击我们的应用，这就是漏洞。如下 图：<img src="https://cdn.nlark.com/yuque/0/2022/png/29328785/1660641287176-6e6e4cac-8c1d-4b0d-bd66-4f613bf33ead.png#averageHue=%23f7f7f7&amp;clientId=ud7ae0ffa-882b-4&amp;from=paste&amp;height=504&amp;id=u6439269d&amp;originHeight=630&amp;originWidth=938&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=109277&amp;status=done&amp;style=none&amp;taskId=uf77f5c12-d728-4a0e-87c2-f70b3fbd1a2&amp;title=&amp;width=750.4#averageHue=%23f7f7f7&amp;id=bq3rl&amp;originHeight=630&amp;originWidth=938&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none#averageHue=%23f7f7f7&amp;from=url&amp;id=QQrqH&amp;originHeight=630&amp;originWidth=938&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt="">有两种方案可以解决： 方案一，缓存空对象：当从 DB 查询数据为空，我们仍然将这个空结果进行缓存，具体的值需要使用特殊 的标识，能和真正缓存的数据区分开。另外，需要设置较短的过期时间，一般建议不要超过 5 分钟。 方案二，BloomFilter 布隆过滤器：在缓存服务的基础上，构建 BloomFilter 数据结构，在 BloomFilter 中存储对应的 KEY 是否存在，如果存在，说明该 KEY 对应的值为空。那么整个逻辑的 如下：1、根据 KEY 查询缓存。如果存在对应的值，直接返回；如果不存在，继续向下执行。 2、根据 KEY 查询在缓存 BloomFilter 的值。如果存在值，说明该 KEY 不存在对应的值，直接 返回空；如果 不存在值，继续向下执行。 3、查询 DB 对应的值，如果存在，则更新到缓存，并返回该值。如果不存在值，更新到 缓存BloomFilter 中，并返回空。 简述：（使用布隆过滤器存储所有可能访问的 key，不存在的 key 直接被过滤，存在的 key 则再进一步查询缓存和数据库。）</p><h2 id="_07-缓存击穿" tabindex="-1"><a class="header-anchor" href="#_07-缓存击穿"><span>07. 缓存击穿</span></a></h2><p>缓存击穿是指：某一个热点key，缓存中没有但数据库中有的数据（一般是缓存时间到期），这时由于并发用户特别多，同时读缓存没读到数据，又同时去数据库去取数据，引起数据库压力瞬间增大，造成过大压力解决方案：</p><ol><li>设置热点数据永远不过期：直接将缓存设置为不过期，然后由定时任务去异步加载数据，更新缓存。这种方式适用于比较极端的场景，例如流量特别特别大的场景，使用时需要考虑业务能接受数据不一致的时间，还有就是异常情况的处理，不要到时候缓存刷新不上，一直是脏数据，那就凉了。</li><li>加互斥锁：该方式和缓存击穿一样，按 key 维度加锁，对于同一个 key，只允许一个线程去计算，其他线程原地阻塞等待第一个线程的计算结果，然后直接走缓存即可。。在并发的多个请求中，只有第一个请求线程能拿到锁并执行数据库查询操作，其他的线程拿不到锁就阻塞等着，等到第一个线程将数据写入缓存后，直接走缓存。</li></ol><h2 id="_08-缓存预热" tabindex="-1"><a class="header-anchor" href="#_08-缓存预热"><span>08.缓存预热</span></a></h2><p>缓存预热就是系统上线后，将相关的缓存数据直接加载到缓存系统。这样就可以避免在用户请求的时候， 先查询数据库，然后再将数据缓存的问题！用户直接查询事先被预热的缓存数据！</p><h2 id="_09-缓存更新" tabindex="-1"><a class="header-anchor" href="#_09-缓存更新"><span>09.缓存更新</span></a></h2><p>缓存更新除了缓存服务器自带的缓存失效策略之外（Redis 默认的有 6 中策略可供选择），我们还可以 根据具体的业务需求进行自定义的缓存淘汰，常见的策略有两种： （1）定时去清理过期的缓存； （2）当有用户请求过来时，再判断这个请求所用到的缓存是否过期，过期的话就去底层系统得到新数 据并更新缓存</p><h2 id="_10-缓存降级" tabindex="-1"><a class="header-anchor" href="#_10-缓存降级"><span>10.缓存降级</span></a></h2><p>当访问量剧增、服务出现问题（如响应时间慢或不响应）或非核心服务影响到核心流程的性能时，仍然 需要保证服务还是可用的，即使是有损服务。系统可以根据一些关键数据进行自动降级，也可以配置开 关实现人工降级。降级的最终目的是保证核心服务可用，即使是有损的。而且有些服务是无法降级的 （如加入购物车、结算）。</p><h2 id="_11-redis-有几种数据淘汰策略" tabindex="-1"><a class="header-anchor" href="#_11-redis-有几种数据淘汰策略"><span>11.Redis 有几种数据淘汰策略</span></a></h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/29328785/1660642331752-0f78feba-195a-4987-9d95-265a9672e686.png#averageHue=%23f3f0df&amp;clientId=ud7ae0ffa-882b-4&amp;from=paste&amp;height=286&amp;id=u1c8204ac&amp;originHeight=357&amp;originWidth=966&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=123663&amp;status=done&amp;style=none&amp;taskId=uaf62d3f2-5acb-42ff-b1dc-cc042cd4657&amp;title=&amp;width=772.8#averageHue=%23f3f0df&amp;id=WWjY6&amp;originHeight=357&amp;originWidth=966&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none#averageHue=%23f3f0df&amp;from=url&amp;id=m1UJ0&amp;originHeight=357&amp;originWidth=966&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""> Redis 提供了 6 种数据淘汰策略： volatile-lru volatile-ttl volatile-random allkeys-lru allkeys-random 【默认策略】no-enviction 在 Redis 4.0 后，基于 LFU（Least Frequently Used）最近最少使用算法，增加了 2 种淘汰 策略： volatile-lfu allkeys-lfu 1.noeviction 不进行数据淘汰，也是Redis的默认配置。这时，当缓存被写满时，再有写请求进来，Redis不再提供 服务，直接返回错误。 2.volatile-random 缓存满了之后，在设置了过期时间的键值对中进行随机删除。 3.volatile-ttl 缓存满了之后，会针对设置了过期时间的键值对中，根据过期时间的先后顺序进行删除,越早过期的越先 被删除。 4.volatile-lru 缓存满了之后，针对设置了过期时间的键值对，采用LRU算法进行淘汰。 5.volatile-lfu 缓存满了之后，针对设置了过期时间的键值对，采用LFU的算法进行淘汰。 6.allkeys-random 缓存满了之后，从所有键值对中随机选择并删除数据。 7.allkeys-lru 缓存满之后，使用LRU算法在所有的数据中进行筛选删除。 8.allkeys-lfu 缓存满了之后，使用LFU算法在所有的数据中进行筛选删除。</p><h2 id="_12-redis-有几种数据过期策略" tabindex="-1"><a class="header-anchor" href="#_12-redis-有几种数据过期策略"><span>12.Redis 有几种数据过期策略</span></a></h2><p>Redis 的过期策略，就是指当 Redis 中缓存的 key 过期了，Redis 如何处理 Redis 提供了 3 种数据过期策略： 被动删除：当读/写一个已经过期的 key 时，会触发惰性删除策略，直接删除掉这个过期 key 。 主动删除：由于惰性删除策略无法保证冷数据被及时删掉，所以 Redis 会定期主动淘汰一批已过期的 key 。 主动删除：当前已用内存超过 maxmemory 限定时，触发主动清理策略，即 「数据“淘汰”策略」 。 在 Redis 中，同时使用了上述 3 种策略，即它们非互斥的</p><h2 id="_13-redis-支持的-java-客户端都有哪些" tabindex="-1"><a class="header-anchor" href="#_13-redis-支持的-java-客户端都有哪些"><span>13.Redis 支持的 Java 客户端都有哪些</span></a></h2><p>使用比较广泛的有三个 Java 客户端 1、Redisson ，是一个高级的分布式协调 Redis 客服端，能帮助用户在分布式环境中轻松实现一些 Java 的对象 (Bloom filter, BitSet, Set, SetMultimap, ScoredSortedSet, SortedSet, Map, ConcurrentMap, List, ListMultimap, Queue, BlockingQueue, Deque, BlockingDeque, Semaphore, Lock, ReadWriteLock, AtomicLong, CountDownLatch, Publish / Subscribe, HyperLogLog)。 2、Jedis 是 Redis 的 Java 实现的客户端，其 API 提供了比较全面的 Redis 命令的支持。 Redisson 实现了分布式和可扩展的 Java 数据结构，和 Jedis 相比，Jedis 功能较为简单。 Redisson 的宗旨是促进使用者对 Redis 的关注分离，从而让使用者能够将精力更集中地放在处理业务逻辑上。 3、Lettuce 是一个可伸缩线程安全的 Redis 客户端。多个线程可以共享同一个RedisConnection 。它利用优秀 Netty NIO 框架来高效地管理多个连接 Redis 官方推荐使用 Redisson 或 Jedis</p><h2 id="_14-如何使用-redis-实现分布式锁" tabindex="-1"><a class="header-anchor" href="#_14-如何使用-redis-实现分布式锁"><span>14.如何使用 Redis 实现分布式锁</span></a></h2><p>1、正确的获得锁（set 指令附带 nx 参数，保证有且只有一个进程获得到。） 2、正确的释放锁（使用 Lua 脚本，比对锁持有的是不是自己。如果是，则进行删除来释放） 3、超时的自动释放锁（set 指令附带 expire 参数，通过过期机制来实现超时释放） 4、未获得到锁的等待机制（sleep 或者基于 Redis 的订阅 Pub/Sub 机制。一些业务场景，可能需要支持获得不到锁，直接返回 false ，不等待） 5、【可选】锁的重入性 通过 ThreadLocal 记录是第几次获得相同的锁。 1）有且第一次计数为 1 &amp;&amp; 获得锁时，才向 Redis 发起获得锁的操作。 2）有且计数为 0 &amp;&amp; 释放锁时，才向 Redis 发起释放锁的操作。 6、锁超时的处理（一般情况下，可以考虑告警 + 后台线程自动续锁的超时时间。通过这样的机制，保证 有且仅有一个线程，正在持有锁。）</p><h2 id="_15-什么是-redis-事务" tabindex="-1"><a class="header-anchor" href="#_15-什么是-redis-事务"><span>15.什么是 Redis 事务</span></a></h2><p>在 Redis 中，MULTI / EXEC / DISCARD / WATCH 这四个命令是我们实现事务的基石 1、可以通过 MULTI 命令开启一个事务 2、可以通过执行 EXEC / DISCARD 命令来提交 / 回滚该事务内的所有操作 3、在 Redis 的事务中，WATCH 命令可用于提供 CAS(check-and-set) 功能，假设我们通过 WATCH 命令在事务执行之前监控了多个 keys ，倘若在 WATCH 之后有任何 Key 的值发生了变化， EXEC 命令执行的事务都将被放弃，同时返回 nil 应答以通知调用者事务执行失败。</p><h2 id="_16-redis集群有哪些方案" tabindex="-1"><a class="header-anchor" href="#_16-redis集群有哪些方案"><span>16.Redis集群有哪些方案</span></a></h2><p>1、Redis Sentinel 2、Redis Cluster 3、Twemproxy 4、Codis 5、客户端分片 目前一般在选型上来说： 体量较小时，选择 Redis Sentinel ，单主 Redis 足以支撑业务。 体量较大时，选择 Redis Cluster ，通过分片，使用更多内存。</p><h2 id="_17-一个-redis-实例最多能存放多少的-keys-list、set、sorted-set-他们最多能存放多少元素" tabindex="-1"><a class="header-anchor" href="#_17-一个-redis-实例最多能存放多少的-keys-list、set、sorted-set-他们最多能存放多少元素"><span>17.一个 Redis 实例最多能存放多少的 keys？List、Set、Sorted Set 他们最多能存放多少元素</span></a></h2><p>理论上，Redis 可以处理多达 2^32 的 keys ，并且在实际中进行了测试，每个实例至少存放了 2 亿 5 千万的 keys。 任何 list、set、和 sorted set 都可以放 2^32 个元素</p><h2 id="_18-redis是多线程还是单线程" tabindex="-1"><a class="header-anchor" href="#_18-redis是多线程还是单线程"><span>18. redis是多线程还是单线程：</span></a></h2><p>命令执行过程都为单线程，6.0之前:链接，传输使用多路复用的模式命令执行过程都为单线程，6.0之后:链接，传输使用多线程的模式</p><h2 id="_19-redis三种集群模式" tabindex="-1"><a class="header-anchor" href="#_19-redis三种集群模式"><span>19. Redis三种集群模式</span></a></h2><ul><li>redis有三种集群模式，其中主从是最常见的模式。</li><li>Sentinel 哨兵模式是为了弥补主从复制集群中主机宕机后，主备切换的复杂性而演变出来的。哨兵顾名思义，就是用来监控的，主要作用就是监控主从集群，自动切换主备，完成集群故障转移。</li><li>cluster 模式是redis官方提供的集群模式，使用了Sharding 技术，不仅实现了高可用、读写分离、也实现了真正的分布式存储。</li></ul><h2 id="_20-reids主从模式" tabindex="-1"><a class="header-anchor" href="#_20-reids主从模式"><span>20. reids主从模式</span></a></h2><p>在 Redis 主从模式下，主库负责处理读写命令以及向从库同步最新数据，从库只负责处理读命令。<img src="https://cdn.nlark.com/yuque/0/2022/png/29328785/1660702780949-24ccb292-475a-410c-a9da-ca2ba76037c8.png#averageHue=%23f9f9f9&amp;clientId=u34a162a4-3cf1-4&amp;from=paste&amp;height=280&amp;id=u985888f6&amp;originHeight=350&amp;originWidth=846&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=103173&amp;status=done&amp;style=none&amp;taskId=ue330972a-4981-43c8-8509-48f66e8b515&amp;title=&amp;width=676.8#averageHue=%23f9f9f9&amp;id=Aeuz1&amp;originHeight=350&amp;originWidth=846&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none#averageHue=%23f9f9f9&amp;from=url&amp;id=IO3Hj&amp;originHeight=350&amp;originWidth=846&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><h2 id="_21、redis复制原理" tabindex="-1"><a class="header-anchor" href="#_21、redis复制原理"><span>21、redis复制原理</span></a></h2><p>Redis 的复制分为两部分操作 同步（SYNC）和 命令传播（command propagate）</p><ul><li>同步（SYNC）从服务器主动获取 主服务器的数据。保持数据一致。具体实现是，主服务器收到SYNC命令后，生成RDB快照文件，然后发送给从服务器。</li><li>命令传播（command propagate）主服务器收到客户端修改数据命令后，数据库数据发生变化，同时将命令缓存起来，然后将缓存命令发送到从服务器，从服务器通过载入缓存命令来达到主从数据一致。</li><li>为什么需要有同步和命令传播的两种复制操作： 当只有同步操作时候，那么在从服务器向主服务器发送SYNC命令时候，主服务器在生成RDB快照文件时候，仍然会收到客户端的命令修改数据状态，这部分数据如果不能传达给从服务器，那么就会出现主从数据不一致的现象。这时候就出现了命令传播，主服务器收到从服务器的SYNC命令后，生成RDB快照文件同时，将此段时间内收到的命令缓存起来，然后使用命令传播的操作发送从服务器。来达到主从数据一致。</li></ul><h2 id="_22-redis主从复制原理与优缺点" tabindex="-1"><a class="header-anchor" href="#_22-redis主从复制原理与优缺点"><span>22. Redis主从复制原理与<strong>优缺点</strong></span></a></h2><p>主从复制，是指将一台 Redis 服务器的数据，复制到其他的 Redis 服务器。数据的复制是单向的，只能由主节点到从节点。默认情况下，每台 Redis 服务器都是主节点；且一个主节点可以有多个从节点(或没有从节点)，但一个从节点只能有一个主节点。<img src="https://cdn.nlark.com/yuque/0/2022/png/29328785/1660703200987-52a6b641-11a5-45c9-99a7-fce335dec6de.png#averageHue=%23ededed&amp;clientId=u34a162a4-3cf1-4&amp;from=paste&amp;height=126&amp;id=ua56f4d8f&amp;originHeight=157&amp;originWidth=372&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=36613&amp;status=done&amp;style=none&amp;taskId=ub9bda163-a4aa-4505-9496-16fabc4316f&amp;title=&amp;width=297.6#averageHue=%23ededed&amp;id=NYDRM&amp;originHeight=157&amp;originWidth=372&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none#averageHue=%23ededed&amp;from=url&amp;id=DNDzv&amp;originHeight=157&amp;originWidth=372&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt="">优点：</p><ul><li>1、实现读写分离，提高了可用性，解决了单机故障</li><li>2、主从复制期间master和slave都是非阻塞方式，仍然可用。</li></ul><p>缺点：</p><ul><li>1、master宕机期间，需要手动切换主机，同时会有部分数据不能及时同步从服务器，造成数据不一致（需要人工手动介入）</li><li>2、slave宕机后，多个slave恢复后，大量的SYNC同步会造成master IO压力倍增（可以手动规避启动时间）</li><li>3、在线扩容较复杂。</li></ul><h2 id="_23-sentinel-哨兵模式-cluster模式-介绍" tabindex="-1"><a class="header-anchor" href="#_23-sentinel-哨兵模式-cluster模式-介绍"><span>23. Sentinel 哨兵模式 cluster模式 介绍</span></a></h2><h2 id="_24-redisson分布式锁原理" tabindex="-1"><a class="header-anchor" href="#_24-redisson分布式锁原理"><span>24. Redisson分布式锁原理</span></a></h2><h2 id="_25-redis的应用场景" tabindex="-1"><a class="header-anchor" href="#_25-redis的应用场景"><span>25.Redis的应用场景</span></a></h2><p>顶替部分数据库做热点数据持久化，减轻数据库压力； 字符串数字的原子新增可以做分布式 id； list 可以做消息流； hash 可以做购物车； set 可以做关注，可以做抽奖； zset 可以做排行榜；</p><h1 id="redis-高级" tabindex="-1"><a class="header-anchor" href="#redis-高级"><span>redis 高级</span></a></h1><h4 id="_1、说说redis-了解redis源码吗" tabindex="-1"><a class="header-anchor" href="#_1、说说redis-了解redis源码吗"><span>1、说说redis，了解redis源码吗?</span></a></h4><blockquote><p>redis 是什么，有哪些特点，架构是，如何实现高并发的，应用场景是？redis源码宏观分为两大部分。</p></blockquote><p>1.Redis是一种开源的、基于内存的数据库系统，它可以用作数据库、缓存和消息中间件。 2.Redis特点是 **内存中存储：<strong>快</strong> , 支持数据持久化：<strong>RDB和AOF</strong>,  支持事务:<strong>原子性</strong>， 丰富的数据类型：**字符串、列表、集合、有序集合、散列、位图等。 <strong>发布/订阅功能主从复制</strong>备份和读写分离， **哨兵系统集群：**数据分片和分布式存储， **单线程：**IO多路</p><p><strong>1.简介Redis</strong></p><p>Redis是一种高性能的开源key-value内存数据库。Redis的特点是速度快，可以处理非常大的数据集，而且具有很强的可扩展性和数据持久化功能。 Redis采用单线程模型，通过异步IO和事件驱动机制实现高并发。其架构包括网络层、客户端请求处理、命令执行引擎、键空间与过期管理、持久化、复制、Sentinel（哨兵）以及集群等模块。</p><p><strong>2.Redis特点：</strong></p><p>** 1.内存中存储**：数据存储在内存中，读写速度快。</p><ol start="2"><li><strong>支持数据持久化</strong>：通过RDB和AOF机制，可以将内存中的数据保存到磁盘。</li><li><strong>支持事务</strong>：提供事务功能，确保操作的原子性。</li><li><strong>丰富的数据类型</strong>：支持字符串、列表、集合、有序集合、散列、位图等。</li><li><strong>发布/订阅功能</strong>：支持消息发布和订阅机制。</li><li><strong>主从复制</strong>：支持数据的备份和读写分离。</li><li><strong>哨兵系统</strong>：监控主服务器状态，自动故障转移。</li><li><strong>集群</strong>：支持数据分片和分布式存储。</li><li><strong>单线程模型</strong>：尽管是单线程，但通过IO多路复用技术实现高并发。</li></ol><p><strong>3.Redis架构：</strong></p><p>** 1.网络层**：处理客户端的TCP连接和请求。</p><ol start="2"><li><strong>事件循环</strong>：使用epoll或kqueue等IO多路复用技术，处理文件事件和时间事件。</li><li><strong>命令处理</strong>：解析和执行Redis命令。</li><li><strong>数据存储</strong>：内存中的数据结构和持久化到磁盘的机制。</li><li><strong>复制和集群</strong>：实现数据的备份和分布式存储。</li><li><strong>持久化模块</strong>：RDB和AOF持久化机制的实现。</li><li><strong>哨兵模块</strong>：监控和故障转移的实现。</li></ol><p><strong>4.Redis如何实现高并发：</strong></p><ol><li><strong>单线程事件循环</strong>：Redis使用单线程模型，通过IO多路复用技术（如epoll）来处理大量的并发连接。</li><li><strong>内存中操作</strong>：数据存储在内存中，减少了磁盘I/O操作，提高了处理速度。</li><li><strong>高效的数据结构</strong>：使用高效的数据结构来优化数据操作的性能。</li><li><strong>无锁编程</strong>：避免了多线程编程中的锁竞争问题，减少了上下文切换的开销。</li></ol><p><strong>5.Redis应用</strong></p><ol><li><strong>缓存</strong>：Redis可以作为缓存系统，用于存储热点数据，提高应用程序的响应速度。</li><li><strong>数据库</strong>：Redis可以用作数据库，用于存储数据，支持多种数据结构和事务。</li><li><strong>消息队列</strong>：Redis可以作为消息队列，用于异步消息的传递和处理。</li><li><strong>分布式系统</strong>：Redis支持分布式架构，可以用于实现分布式数据存储和分布式计算。</li><li><strong>监控和日志</strong>：Redis可以用于存储监控数据和日志，支持数据的快速查询和分析。</li><li><strong>排行榜和计数器</strong>：实现实时更新的排行榜。</li><li><strong>实时分析</strong>：进行实时数据统计和分析。</li><li><strong>全页缓存</strong>：缓存整个页面或页面片段。</li><li><strong>分布式锁</strong>：实现跨多个应用实例的锁机制。</li><li><strong>地理位置服务</strong>：存储和查询地理位置数据。</li></ol><p><strong>6.Redis的源码</strong> Redis由两大部分构成：服务器和客户端，它们通过TCP协议进行通信。</p><ul><li>Redis服务器是用C语言编写的，负责底层数据存储和处理逻辑。（下面详解）</li><li>Redis客户端可以由不同的编程语言实现，提供了与Redis服务器交互的接口。</li></ul><p>Redis源码的架构： 核心代码## 辅助模块## 性能优化## 安全性## 可维护性## 测试## 文档和社区支持</p><p><strong>7.Redis服务器源码包括以下几个部分：</strong> 核心模块</p><ul><li><strong>协议栈</strong>：处理客户端连接和基于RESP的通信。</li><li><strong>内存管理</strong>：高效的内存分配和释放，内存碎片整理。</li><li><strong>数据结构</strong>：实现多种数据类型，如字符串、列表、集合等。</li><li><strong>命令执行</strong>：解析和执行命令，保证原子性和一致性。</li></ul><p>辅助模块 (Auxiliary Modules)核心模块</p><ul><li><strong>持久化</strong>：RDB和AOF两种持久化机制。</li><li><strong>复制</strong>：主从复制机制，支持数据备份和扩展读操作。</li><li><strong>哨兵</strong>：Redis Sentinel监控和自动故障转移。</li><li><strong>集群</strong>：Redis Cluster支持数据分片和分布式存储。</li><li><strong>Lua脚本</strong>：服务器端Lua脚本执行。</li><li><strong>发布/订阅</strong>：消息传递和通知的发布/订阅模式。</li><li><strong>事务</strong>：支持批量命令的原子性执行。</li><li><strong>模块系统</strong>：动态加载和卸载模块，便于功能扩展。</li></ul><p>Redis服务器源码非常庞大和复杂，如果要完整地研究和理解Redis的源码，需要有较强的编程能力和C/C++语言基础。</p><h4 id="_2-聊聊-为什么使用redis-阿里一面" tabindex="-1"><a class="header-anchor" href="#_2-聊聊-为什么使用redis-阿里一面"><span>2.聊聊：为什么使用redis（阿里一面）</span></a></h4><p><strong>核心概念为</strong>：并发+性能</p><p>在面试中被问到为什么使用Redis，特别是在涉及并发和性能的话题时，通常有几个关键的理由可以作为回答的核心： ** 1.性能： **我们在碰到需要执行耗时特别久，且结果不频繁变动的SQL，就特别适合将运行结果放入缓存。这样， 后面的请求就去缓存中读取，使得请求能够迅速响应。 ** 2.并发： **在大并发的情况下，所有的请求直接访问数据库，数据库会出现连接异常。这个时候，就需要使用redis 做一个缓冲操作，让请求先访问到redis，而不是直接访问数据库。</p><h4 id="_3-聊聊-redis-都有哪些数据类型-分别在哪些场景下使用比较合适-1-3" tabindex="-1"><a class="header-anchor" href="#_3-聊聊-redis-都有哪些数据类型-分别在哪些场景下使用比较合适-1-3"><span>3.聊聊：redis 都有哪些数据类型？分别在哪些场景下使用比较合适？（1-3）</span></a></h4><h4 id="_4-redis-的过期策略是啥" tabindex="-1"><a class="header-anchor" href="#_4-redis-的过期策略是啥"><span>4.redis 的过期策略是啥？</span></a></h4><h4 id="_5-redis为什么快呢" tabindex="-1"><a class="header-anchor" href="#_5-redis为什么快呢"><span><strong>5.Redis</strong>为什么快呢？</span></a></h4><p>Redis的速度非常快，单机的Redis可以支撑每秒十几万的并发，相对于MySQL来说，性能是MySQL的几十倍。速度快的原因主要有以下几点：</p><ul><li><ol><li>完全基于内存操作</li></ol></li><li><ol start="2"><li>使用单线程，避免了线程切换和竞态产生的消耗</li></ol></li><li><ol start="3"><li>基于非阻塞的IO多路复用机制</li></ol></li><li><ol start="4"><li>C语言实现，优化过的数据结构</li></ol></li></ul><h5 id="_1-基于内存实现" tabindex="-1"><a class="header-anchor" href="#_1-基于内存实现"><span>1.基于内存实现</span></a></h5><p>Redis是基于内存的数据库，与磁盘数据库（如MySQL）相比，其访问速度要快得多。MySQL是关系型数据库，主要用于存放持久化数据，将数据存储在硬盘中，读取速度较慢，每次请求访问数据库时，都存在I/O操作。 如果反复频繁访问数据库，会导致高负载。而Redis作为基于内存的缓存数据库，用于存储频繁使用的数据，从而减少访问数据库的次数，提高运行效率。</p><h5 id="_2-高效的数据结构" tabindex="-1"><a class="header-anchor" href="#_2-高效的数据结构"><span>2.高效的数据结构</span></a></h5><p><img src="https://cdn.nlark.com/yuque/0/2024/png/45710781/1719197800279-2711b931-842b-4342-a5fc-0daf230d5bd6.png#averageHue=%23b6b6b4&amp;clientId=u29bbc1e3-5b41-4&amp;from=paste&amp;height=283&amp;id=SRH12&amp;originHeight=283&amp;originWidth=1528&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=101292&amp;status=done&amp;style=none&amp;taskId=u838a0ecf-5564-4691-9046-e4a0bc9d9ce&amp;title=&amp;width=1528" alt="image.png"> Redis底层数据结构一共有六种：简单动态字符串（SDS）、双向链表、压缩列表、哈希表、跳表和整数数组。它们和数据类型的对应关系如下：</p><p><strong>2.1 SDS（简单动态字符串）</strong></p><p>Redis使用SDS（Simple Dynamic String）结构体来保存字符串，而不是C语言中的字符串。SDS与C字符串的区别主要有： <img src="https://cdn.nlark.com/yuque/0/2024/png/45710781/1719198978542-6f126bd0-ba6e-4100-a848-ad2b163a5fc6.png#averageHue=%23d6ccac&amp;clientId=u29bbc1e3-5b41-4&amp;from=paste&amp;height=343&amp;id=ubfb7cd52&amp;originHeight=343&amp;originWidth=753&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=69923&amp;status=done&amp;style=none&amp;taskId=u95ada952-eb6e-4230-923a-547b21caa5a&amp;title=&amp;width=753" alt="image.png"></p><ul><li><strong>字符串长度</strong>：SDS中保存着字符串的长度，可以在常数时间内获取字符串长度。</li><li><strong>拒绝缓冲区溢出</strong>：SDS在修改时会检查空间是否足够，避免缓冲区溢出。</li><li><strong>减少字符串修改时的内存重新分配次数</strong>：SDS实现了空间预分配和惰性空间释放两种优化策略。</li><li><strong>二进制安全</strong>：SDS可以存储二进制数据，不会受到特殊字符的影响。</li></ul><p><strong>2.2 哈希表（字典）</strong> Redis作为k-v型内存数据库，所有的键值对是用字典来存储。哈希表的特性使得可以在O(1)时间复杂度内获得对应的值。</p><p><strong>2.3 跳表</strong> 跳表在链表的基础上增加了多级索引来提升查找效率。跳表可以在O(logN)的时间复杂度里查找到对应的节点。 <img src="https://cdn.nlark.com/yuque/0/2024/png/45710781/1719199022684-3c67aeba-0d40-4d51-ad91-ae3065837ad0.png#averageHue=%23d9d1b8&amp;clientId=u29bbc1e3-5b41-4&amp;from=paste&amp;height=242&amp;id=u19b464bb&amp;originHeight=242&amp;originWidth=741&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=34177&amp;status=done&amp;style=none&amp;taskId=u46531263-9cc4-49be-a03e-a55ab23b4db&amp;title=&amp;width=741" alt="image.png"></p><p><strong>2.4 双向链表</strong></p><p>列表（List）更多是被当作队列或栈来使用的。双向链表支持先进先出和先进后出的特性，链表中的每个节点都带有两个指针，可以在O(1)时间复杂度内获取到前后节点。</p><p><strong>2.5 压缩列表</strong><img src="https://cdn.nlark.com/yuque/0/2024/png/45710781/1719199064818-c6ff2d5a-a1ea-4f65-abe7-c694be81a179.png#averageHue=%23d8d1b7&amp;clientId=u29bbc1e3-5b41-4&amp;from=paste&amp;height=247&amp;id=u25d73823&amp;originHeight=247&amp;originWidth=753&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=57225&amp;status=done&amp;style=none&amp;taskId=ue1f4335c-c342-4966-ba55-712a71f1be2&amp;title=&amp;width=753" alt="image.png"> 压缩列表是Redis为了节约内存而开发的，是由一系列特殊编码的连续内存块组成的顺序型数据结构。压缩列表的内存是连续分配的，遍历速度很快。</p><h5 id="_3-io多路复用模型" tabindex="-1"><a class="header-anchor" href="#_3-io多路复用模型"><span>3.IO多路复用模型</span></a></h5><p>** IO多路复用**（I/O Multiplexing）是一种在单个线程内同时监控多个文件描述符（如网络连接、文件等）的方法。 当任何一个文件描述符就绪（例如有数据到达可以读，或者可以写数据）时，程序就可以处理相应的IO操作。常见的IO多路复用机制包括select、poll和epoll等。</p><h5 id="_4-避免上下文切换" tabindex="-1"><a class="header-anchor" href="#_4-避免上下文切换"><span>4.避免上下文切换</span></a></h5><p>Redis使用单线程模型避免了多线程的上下文切换问题。多线程在执行过程中需要进行CPU的上下文切换，而Redis基于内存操作，没有上下文切换，效率更高。多次读写都在一个CPU上，对于内存来说是最佳方案。</p><h4 id="_6-redis为什么最开始被设计成单线程的" tabindex="-1"><a class="header-anchor" href="#_6-redis为什么最开始被设计成单线程的"><span><strong>6.Redis为什么最开始被设计成单线程的？</strong></span></a></h4><p>Redis 是一个成熟的分布式缓存框架，由多个模块组成，包括网络请求模块、索引模块、存储模块、高可用集群支撑模块和数据操作模块等。</p><p><strong>1.单线程与多线程</strong></p><p>在 Redis 中，只有网络请求模块和数据操作模块是单线程的，而其他如持久化存储模块和集群支撑模块是多线程的。单线程意味着网络请求模块使用一个线程处理所有网络请求，不需考虑并发安全性，而其他模块则使用多个线程。</p><p><strong>2.为什么网络操作和数据存储模块最初没有使用多线程？</strong></p><p>多线程的目的是通过并发提升 I/O 和 CPU 的利用率。 Redis 不需要提升 CPU 利用率，因为它的操作主要基于内存，CPU 资源不是性能瓶颈。因此，通过多线程提升 Redis 的 CPU 利用率是没有必要的。虽然多线程可以提升 I/O 利用率，但也带来了并发问题和性能开销。因此，Redis 选择了多路复用 I/O 技术而非多线程技术来提升 I/O 利用率。</p><p><strong>3.官方解释</strong></p><p><a href="https://redis.io/topics/faq" target="_blank" rel="noopener noreferrer">官方 FAQ</a> 提供了进一步解释。一个程序在执行过程中，主要进行读写操作（I/O 操作，包括网络 I/O 和磁盘 I/O）和计算操作（CPU 操作）。因为 Redis 基于内存操作，CPU 成为瓶颈的情况很少见。Redis 的瓶颈更可能是内存大小或网络限制。如果要最大化利用 CPU，可以在一台机器上 启动多个 Redis 实例。</p><p>4.Redis 4.0 之后的多线程支持</p><p>在 Redis 4.0 之后，除了主线程外，Redis 还引入了后台线程来处理一些较为缓慢的操作，例如清理脏数据、释放无用连接和删除大 Key 等等。</p><h4 id="_7-redis-的io处理线程模型" tabindex="-1"><a class="header-anchor" href="#_7-redis-的io处理线程模型"><span>7.redis 的IO处理线程模型</span></a></h4><p>Redis 内部使用<strong>文件事件处理器</strong>（file event handler），这是其单线程模型的核心。这种模型与 Netty 的 Reactor 反应器模型类似，它利用了 IO 多路复用机制来同时监听多个 socket。这种机制允许 Redis 将产生事件的 socket 压入内存队列中，然后由事件分派器根据 socket 上的事件类型，选择相应的事件处理器进行处理。</p><p><strong>1.文件事件处理器结构</strong></p><p>文件事件处理器结构由以下四个主要部分组成：</p><ol><li><strong>多个 socket</strong>：Redis 可以同时监听多个 socket。</li><li><strong>IO 多路复用程序</strong>：用于监听这些 socket，并将事件放入队列。</li><li><strong>文件事件分派器</strong>：负责从队列中取出 socket，并根据事件类型进行分派。</li><li><strong>事件处理器</strong>：包括连接应答处理器、命令请求处理器、命令回复处理器等，它们负责具体的事件处理工作。</li></ol><p>尽管<strong>多个 socket</strong>可能会并发产生不同的操作，每个操作对应不同的文件事件，但 IO 多路复用程序能够高效地将这些事件统一管理。事件分派器每次从队列中取出一个 socket，然后根据其事件类型，交由相应的事件处理器进行处理。</p><h4 id="_8-为什么redis-6-0-引入多线程" tabindex="-1"><a class="header-anchor" href="#_8-为什么redis-6-0-引入多线程"><span>8.为什么Redis 6.0 引入多线程</span></a></h4><p>Redis 6.0引入多线程主要是为了解决一些性能瓶颈问题。以下是引入多线程的几个关键原因：</p><ol><li><strong>网络IO瓶颈</strong>：尽管Redis使用单线程模型，但网络IO处理成为了性能瓶颈。在高并发情况下，单线程处理网络请求可能会变得不够高效。</li><li><strong>多路复用技术的局限</strong>：Redis之前使用的IO多路复用技术，如<code>select</code>，本质上是同步阻塞型的。这意味着在等待数据时，它们会阻塞线程，限制了处理能力。</li><li><strong>多核CPU优势未充分利用</strong>：现代服务器通常配备多个CPU核心，但Redis的单线程模型并未充分利用这些核心，导致CPU资源没有得到最佳利用。</li><li><strong>提升性能</strong>：通过引入多线程，Redis可以并发处理网络请求，减少网络I/O等待时间，从而提升性能。</li><li><strong>保持核心操作的单线程</strong>：Redis 6.0中，数据的读写命令仍然由单线程处理，以保持操作的原子性和避免并发问题。多线程主要用于网络请求的接收、解析和响应发送。</li><li><strong>整体性能提升</strong>：通过这种方式，Redis 6.0旨在提高网络IO处理效率，同时利用多核CPU的优势，从而整体提升性能。</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2024/png/45710781/1719201706325-dad6fa1d-425d-4052-a9fa-f70c2e5268e5.png#averageHue=%23d7be9f&amp;clientId=u29bbc1e3-5b41-4&amp;from=paste&amp;height=385&amp;id=u79dcbc66&amp;originHeight=385&amp;originWidth=708&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=75523&amp;status=done&amp;style=none&amp;taskId=u76d30794-37c8-4a82-b111-ce9e2f513ff&amp;title=&amp;width=708" alt="image.png"> 简而言之，这样做的⽬的是因为Redis的性能瓶颈在于⽹络IO⽽⾮CPU，使⽤多线程能提升IO读写的效率，从⽽整体提⾼Redis的性能。</p><h4 id="_9-redis里面有1亿个key-其中有10w个key是以某个固定的已知的前缀开头的-如何将它们全部找出来" tabindex="-1"><a class="header-anchor" href="#_9-redis里面有1亿个key-其中有10w个key是以某个固定的已知的前缀开头的-如何将它们全部找出来"><span>9.Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如何将它们全部找出来？</span></a></h4><blockquote><p>使用keys指令可以扫出指定模式的key列表。 如果这个redis正在给线上的业务提供服务，那使用keys指令会有什么问题？ 这个时候你要回答redis关键的一个特性： redis的单线程的。 keys指令会导致线程阻塞一段时间，线上服务会停顿，直到指令执行完毕，服务才能恢复。 这个时候可以使用scan指令，scan指令可以无阻塞的提取出指定模式的key列表，但是会有一定的重复 概率，在客户端做一次去重就可以了，但是整体所花费的时间会比直接用keys指令长。</p></blockquote><hr><h4 id="_10-聊聊-redis如何做持久化的" tabindex="-1"><a class="header-anchor" href="#_10-聊聊-redis如何做持久化的"><span>10.聊聊：Redis如何做持久化的？</span></a></h4><p>Redis通过以下两种方式实现持久化：</p><ul><li><strong>bgsave</strong> 做镜像全量持久化（rdb）</li><li><strong>aof</strong> 做增量持久化</li><li></li></ul><p>由于bgsave会耗费较长时间，不够实时，在停机的时候会导致大量丢失数据，因此需要AOF来配合使用。在Redis实例重启时，优先使用AOF来恢复内存的状态，如果没有AOF日志，就会使用RDB文件来恢复。</p><h5 id="bgsave做全量持久化" tabindex="-1"><a class="header-anchor" href="#bgsave做全量持久化"><span>bgsave做全量持久化</span></a></h5><p>RDB是Redis中数据集的时间点快照，在Redis内完成RDB持久化的方法有<code>rdbSave</code>和<code>rdbSaveBackground</code>两个函数方法（源码文件rdb.c中），两者差别如下：</p><ul><li><strong>rdbSave</strong>：同步执行的方法，调用后立刻启动持久化流程。由于Redis是单线程模型，持久化过程中会阻塞，Redis无法对外提供服务。</li><li><strong>rdbSaveBackground</strong>：异步执行的方法，会fork出子进程，真正的持久化过程在子进程中执行（调用rdbSave），主进程继续提供服务。</li></ul><p>RDB持久化的触发方式分为手动和自动。手动触发是指通过Redis客户端发起持久化备份指令，常用的指令有<code>save</code>和<code>bgsave</code>。</p><p>在整个持久化过程中，主进程不进行任何IO操作，全程由子进程完成，确保了极高的性能。如果需要大规模数据恢复且对数据恢复的完整性要求不高，那么RDB方式比AOF方式更高效。但RDB的缺点是最后一次持久化的数据可能会丢失。</p><h5 id="aof做增量持久化" tabindex="-1"><a class="header-anchor" href="#aof做增量持久化"><span>aof做增量持久化</span></a></h5><p>AOF（Append Only File）以日志形式记录每个写操作，将Redis执行的所有写操作指令记录下来（读操作不记录）。文件只许追加，不可改写，Redis重启时会读取该文件重新构建数据。AOF默认保存的文件是<code>appendonly.aof</code>，该文件具有可读性。</p><p>AOF的工作原理类似于MySQL的binlog日志语句复制。AOF文件同步有三种同步策略：</p><ol><li>修改同步</li><li>每秒同步</li><li>不主动调用fsync同步</li></ol><p>AOF优缺点：</p><ul><li>利用appendfsync持久化机制，异步操作每秒记录，数据完整性高于RDB。如果一秒宕机，有可能丢失1秒数据。</li><li>AOF文件要远大于RDB文件，恢复速度要慢于RDB。每秒同步策略效率较好，不同步效率和RDB相同。</li></ul><p>在Redis实例重启时，优先使用AOF来恢复内存的状态，如果没有AOF日志，就会使用RDB文件来恢复。</p><h4 id="_11-聊聊-系统化的介绍一下-redis持久化的机制" tabindex="-1"><a class="header-anchor" href="#_11-聊聊-系统化的介绍一下-redis持久化的机制"><span>11.聊聊：系统化的介绍一下，Redis持久化的机制？</span></a></h4><h5 id="_1-redis的持久化配置" tabindex="-1"><a class="header-anchor" href="#_1-redis的持久化配置"><span>1.Redis的持久化配置</span></a></h5><p>Redis提供两种持久化机制：RDB和AOF。用于在崩溃后恢复数据。RDB和AOF持久化的区别如下：</p><ul><li><strong>RDB持久化</strong>：将数据集生成快照并保存为二进制文件<code>.rdb</code>。优点是单个文件便于备份，恢复速度快。缺点是数据实时性低，可能会丢失最后一次持久化的数据。</li><li><strong>AOF持久化</strong>：以日志形式记录每个写操作。优点是数据实时性高，通过append模式写文件，确保数据一致性。缺点是文件大，恢复速度慢于RDB。</li></ul><h5 id="_2-rdb持久化功能" tabindex="-1"><a class="header-anchor" href="#_2-rdb持久化功能"><span>2.RDB持久化功能</span></a></h5><p>RDB可以通过以下三种方式创建：</p><ol><li>使用<code>SAVE</code>命令手动同步创建RDB文件</li><li>使用<code>BGSAVE</code>命令异步创建RDB文件</li><li>自动创建RDB文件，通过配置文件设定触发条件</li></ol><p>配置文件中的自动持久化配置如下：</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text" data-title="text"><pre class="language-text"><code><span class="line">save 900 1</span>
<span class="line">save 300 10</span>
<span class="line">save 60 10000</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这些配置表示在指定时间内数据发生一定次数的改动时自动执行BGSAVE命令。</p><h5 id="_3-aof持久化功能" tabindex="-1"><a class="header-anchor" href="#_3-aof持久化功能"><span>3.AOF持久化功能</span></a></h5><p>AOF持久化通过记录每个写操作的日志文件实现。AOF文件同步策略有三种：</p><ol><li><code>appendfsync always</code>：每次有数据修改时都写入AOF文件，最安全但性能较低。</li><li><code>appendfsync everysec</code>：每秒同步一次，性能适中，最多丢失1秒的数据。</li><li><code>appendfsync no</code>：不主动调用fsync，由操作系统决定何时写入硬盘，性能最好但数据丢失量不确定。</li></ol><p>推荐将<code>appendfsync</code>选项设定为<code>everysec</code>，在Redis做缓存时，即使数据丢失也不会造成影响。</p><h5 id="_4-rdb和aof的选择" tabindex="-1"><a class="header-anchor" href="#_4-rdb和aof的选择"><span>4.RDB和AOF的选择</span></a></h5><p>一般来说，如果需要数据安全性高，可以同时使用RDB和AOF持久化。在Redis重启时会优先载入AOF文件恢复数据，因为AOF保存的数据集通常比RDB完整。如果可以接受数分钟的数据丢失，可以只使用RDB持久化。</p><hr><h4 id="_12-redis-集群了解吗" tabindex="-1"><a class="header-anchor" href="#_12-redis-集群了解吗"><span>12.Redis 集群了解吗？</span></a></h4><p><strong>数据分区：</strong><br> 数据分区 (或称数据分片) 是集群最核心的功能。 集群将数据分散到多个节点，一方面 突破了 Redis 单机内存大小的限制，存储容量大大增加；另一方面 每个主节点都可以对外提供读服务和写服务，大大提高了集群的响应能力。 数据分片是高扩展的基础。</p><p><strong>高可用：</strong> 集群支持主从复制和主节点的 <strong>自动故障转移</strong> （与哨兵类似），当任一节点发生故障时，集群 仍然可以对外提供服务。</p><h4 id="_13-数据分片-sharding-的基本类型-大致的原理" tabindex="-1"><a class="header-anchor" href="#_13-数据分片-sharding-的基本类型-大致的原理"><span>13.数据分片（sharding）的基本类型？大致的原理？</span></a></h4><p>数据分片，也称为数据分区，是一种将全量数据根据特定规则分散存储到多个数据库或表的技术。</p><p>数据分片主要有以下几种基本类型：</p><ul><li><strong>范围分片</strong>：根据数据的范围将数据分配到不同的节点。</li><li><strong>Key（ID）取模分片</strong>：通过Key的数值对节点数量进行取模来分配数据。</li><li><strong>哈希取余分片</strong>：使用哈希算法后对节点数量取余来分配数据。</li><li><strong>一致性哈希分片</strong>：使用一致性哈希算法来分配数据，减少节点变化时的数据迁移。</li><li><strong>虚拟槽分片</strong>：Redis Cluster使用的分片方式，使用固定的哈希槽来分配数据。</li></ul><h5 id="_1-为什么要进行数据分片" tabindex="-1"><a class="header-anchor" href="#_1-为什么要进行数据分片"><span>1.为什么要进行数据分片？</span></a></h5><p>在处理大规模数据时，单节点可能无法满足性能和存储需求，数据分片可以提高系统的扩展性和可用性。</p><h5 id="_2-分片方式详解" tabindex="-1"><a class="header-anchor" href="#_2-分片方式详解"><span>2.分片方式详解</span></a></h5><p><strong>2.1 Range 分片</strong></p><p>按照连续的数据范围来分配数据，适用于按时间或数据顺序访问的场景，但需注意数据倾斜问题。 <strong>2.2 ID（Key）取模分片</strong></p><p>常用于关系型数据库，通过数据ID对节点数量取模来均匀分配数据。</p><p><strong>2.3 哈希取余分片</strong></p><p>通过哈希算法分散数据，然后根据节点数量取余数来分配数据，保证数据分布均匀。</p><p>优点:配置简单，易于实现。 缺点:节点伸缩时会引起大量数据迁移。</p><p><strong>2.4 一致性哈希分片</strong></p><p>使用一致性哈希算法，将数据分布在一个虚拟的token环上，每个节点负责一定范围的数据。</p><ul><li>优点:节点伸缩时，只影响邻近节点的数据迁移。</li><li>缺点:在数据规模较小时，可能导致某些节点空闲。</li></ul><p><strong>2.5 虚拟槽分片</strong></p><p>Redis Cluster使用的一种分片方式，通过预设的哈希槽来分配数据。</p><p><strong>映射步骤</strong></p><ol><li>预设16384个哈希槽，平均分配给各个节点。</li><li>对每个Key进行CRC16哈希运算。</li><li>哈希结果对16383取余，得到槽编号。</li><li>根据槽编号将数据发送到相应节点。</li><li>节点接收数据，如果在自己的槽编号范围内，则保存数据；否则转发到正确节点。</li></ol><p><strong>优势</strong></p><ul><li>节点扩容或缩容时，只需重新分配哈希槽，数据不会丢失。</li></ul><p>选择合适的数据分片策略需要根据应用场景、数据特性和系统需求综合考虑，以实现最优的系统性能和可扩展性。</p><h4 id="_14-能说说redis集群的原理吗" tabindex="-1"><a class="header-anchor" href="#_14-能说说redis集群的原理吗"><span>14..能说说Redis集群的原理吗？</span></a></h4><p>Redis集群通过数据分区来实现数据的分布式存储，通过自动故障转移实现高可用。</p><h5 id="集群创建" tabindex="-1"><a class="header-anchor" href="#集群创建"><span>集群创建</span></a></h5><p>数据分区是在集群创建的时候完成的。<img src="https://cdn.nlark.com/yuque/0/2024/webp/45710781/1719206083884-7f2b2bea-e353-4ef7-b5be-c83d2bc96b4a.webp#averageHue=%23fbfbfa&amp;clientId=uc947591c-c681-4&amp;from=paste&amp;id=u1b2ca52e&amp;originHeight=198&amp;originWidth=649&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u409ded29-e615-40e4-9ccf-3d81029ad35&amp;title=" alt=""><strong>设置节点</strong>Redis集群一般由多个节点组成，节点数量至少为6个才能保证组成完整高可用的集群。每个节点需要开启配置cluster-enabled yes，让Redis运行在集群模式下。<img src="https://cdn.nlark.com/yuque/0/2024/webp/45710781/1719206083920-6b27d9d7-1c86-4f8c-80c5-1438a35fec24.webp#averageHue=%23f7f7f2&amp;clientId=uc947591c-c681-4&amp;from=paste&amp;id=u202036ed&amp;originHeight=327&amp;originWidth=813&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u479cfd01-d3d2-46b3-8b58-8e93fb7c9ec&amp;title=" alt=""><strong>节点握手</strong>节点握手是指一批运行在集群模式下的节点通过Gossip协议彼此通信， 达到感知对方的过程。节点握手是集群彼此通信的第一步，由客户端发起命 令：cluster meet{ip}{port}。完成节点握手之后，一个个的Redis节点就组成了一个多节点的集群。 **分配槽（slot）**Redis集群把所有的数据映射到16384个槽中。每个节点对应若干个槽，只有当节点分配了槽，才能响应和这些槽关联的键命令。通过 cluster addslots命令为节点分配槽。 <img src="https://cdn.nlark.com/yuque/0/2024/webp/45710781/1719206083946-7c9f8e90-25d5-4e5d-8f0f-f0ea5becaafc.webp#averageHue=%23fbfbf9&amp;clientId=uc947591c-c681-4&amp;from=paste&amp;id=ue0ad6a3b&amp;originHeight=504&amp;originWidth=756&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u553f2ffc-7e1b-4404-afaf-1469c493756&amp;title=" alt=""> 分配槽</p><h5 id="故障转移" tabindex="-1"><a class="header-anchor" href="#故障转移"><span>故障转移</span></a></h5><p>Redis集群的故障转移和哨兵的故障转移类似，但是Redis集群中所有的节点都要承担状态维护的任务。 <strong>故障发现</strong>Redis集群内节点通过ping/pong消息实现节点通信，集群中每个节点都会定期向其他节点发送ping消息，接收节点回复pong 消息作为响应。如果在cluster-node-timeout时间内通信一直失败，则发送节 点会认为接收节点存在故障，把接收节点标记为主观下线（pfail）状态。<img src="https://cdn.nlark.com/yuque/0/2024/webp/45710781/1719206084017-1156f9bf-330e-4fb3-8174-3c472ef67ab1.webp#averageHue=%23fcfcfb&amp;clientId=uc947591c-c681-4&amp;from=paste&amp;id=u17f497f8&amp;originHeight=225&amp;originWidth=491&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u517640f6-045d-4e0d-9dbe-4a4cb3794a1&amp;title=" alt="">当某个节点判断另一个节点主观下线后，相应的节点状态会跟随消息在集群内传播。通过Gossip消息传播，集群内节点不断收集到故障节点的下线报告。当 半数以上持有槽的主节点都标记某个节点是主观下线时。触发客观下线流程。<img src="https://cdn.nlark.com/yuque/0/2024/webp/45710781/1719206084048-8ef38251-abec-45f6-a7b0-80f0540c074c.webp#averageHue=%23fdfcfb&amp;clientId=uc947591c-c681-4&amp;from=paste&amp;id=udef99158&amp;originHeight=512&amp;originWidth=793&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u7ebb3612-010f-4472-b197-e66beb1f48b&amp;title=" alt=""><strong>故障恢复</strong> 故障节点变为客观下线后，如果下线节点是持有槽的主节点则需要在它 的从节点中选出一个替换它，从而保证集群的高可用。 <img src="https://cdn.nlark.com/yuque/0/2024/webp/45710781/1719206084296-f617c854-9a1d-421c-b06f-09e29ef4bdd2.webp#averageHue=%23faf9f6&amp;clientId=uc947591c-c681-4&amp;from=paste&amp;id=ub5963e6a&amp;originHeight=485&amp;originWidth=270&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=ub0049870-ea2e-4d53-895e-304159be353&amp;title=" alt=""> 故障恢复流程</p><ol><li>资格检查 每个从节点都要检查最后与主节点断线时间，判断是否有资格替换故障 的主节点。</li><li>准备选举时间 当从节点符合故障转移资格后，更新触发故障选举的时间，只有到达该 时间后才能执行后续流程。</li><li>发起选举 当从节点定时任务检测到达故障选举时间（failover_auth_time）到达后，发起选举流程。</li><li>选举投票 持有槽的主节点处理故障选举消息。投票过程其实是一个领导者选举的过程，如集群内有N个持有槽的主节 点代表有N张选票。由于在每个配置纪元内持有槽的主节点只能投票给一个 从节点，因此只能有一个从节点获得N/2+1的选票，保证能够找出唯一的从节点。<img src="https://cdn.nlark.com/yuque/0/2024/webp/45710781/1719206084436-3588944c-018a-419b-8bb9-19f55db7aa0d.webp#averageHue=%23fafaf9&amp;clientId=uc947591c-c681-4&amp;from=paste&amp;id=u9c2799c9&amp;originHeight=400&amp;originWidth=779&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u89b7615c-8bdd-4ce2-bb59-99d9cc04bf0&amp;title=" alt=""></li><li>替换主节点 当从节点收集到足够的选票之后，触发替换主节点操作。</li></ol><p><strong>部署Redis集群至少需要几个物理节点？</strong> 在投票选举的环节，故障主节点也算在投票数内，假设集群内节点规模是3主3从，其中有2 个主节点部署在一台机器上，当这台机器宕机时，由于从节点无法收集到 3/2+1个主节点选票将导致故障转移失败。这个问题也适用于故障发现环节。因此部署集群时所有主节点最少需要部署在3台物理机上才能避免单点问题。</p><h4 id="_15-说说集群的伸缩" tabindex="-1"><a class="header-anchor" href="#_15-说说集群的伸缩"><span>15..说说集群的伸缩？</span></a></h4><p>Redis集群提供了灵活的节点扩容和收缩方案，可以在不影响集群对外服务的情况下，为集群添加节点进行扩容也可以下线部分节点进行缩容。<img src="https://cdn.nlark.com/yuque/0/2024/webp/45710781/1719206084382-9197c37f-7754-4b67-ac7b-b9cfee3819ce.webp#averageHue=%23faf9f6&amp;clientId=uc947591c-c681-4&amp;from=paste&amp;id=uec1dad65&amp;originHeight=508&amp;originWidth=588&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u4c03ed35-0eac-4582-9fdf-d0f9d16f283&amp;title=" alt="">其实，集群扩容和缩容的关键点，就在于槽和节点的对应关系，扩容和缩容就是将一部分槽和数据迁移给新节点。 例如下面一个集群，每个节点对应若干个槽，每个槽对应一定的数据，如果希望加入1个节点希望实现集群扩容时，需要通过相关命令把一部分槽和内容迁移给新节点。<img src="https://cdn.nlark.com/yuque/0/2024/webp/45710781/1719206084370-6dd3f5de-d415-4721-adf5-5fd9cf27130a.webp#averageHue=%23ebe9dc&amp;clientId=uc947591c-c681-4&amp;from=paste&amp;id=ub841ecc6&amp;originHeight=479&amp;originWidth=794&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u1c23a3f0-8ae4-4a65-9691-36f4ee88c22&amp;title=" alt="">缩容也是类似，先把槽和数据迁移到其它节点，再把对应的节点下线。</p><h4 id="_16-如何保证本地缓存和分布式缓存的一致" tabindex="-1"><a class="header-anchor" href="#_16-如何保证本地缓存和分布式缓存的一致"><span>16.如何保证本地缓存和分布式缓存的一致？</span></a></h4><p>PS:这道题面试很少问，但实际工作中很常见。 在日常的开发中，我们常常采用两级缓存：本地缓存+分布式缓存。 所谓本地缓存，就是对应服务器的内存缓存，比如Caffeine，分布式缓存基本就是采用Redis。 那么问题来了，本地缓存和分布式缓存怎么保持数据一致？<img src="https://cdn.nlark.com/yuque/0/2024/webp/45710781/1719206460961-9b540b18-4722-4fc5-9845-fed9c845ba56.webp#averageHue=%23faf5f1&amp;clientId=ue723f105-1fb8-4&amp;from=paste&amp;id=ubf8faed5&amp;originHeight=793&amp;originWidth=692&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u6df819d7-14b3-470d-9102-f1d7822f2cc&amp;title=" alt="">Redis缓存，数据库发生更新，直接删除缓存的key即可，因为对于应用系统而言，它是一种中心化的缓存。 但是本地缓存，它是非中心化的，散落在分布式服务的各个节点上，没法通过客户端的请求删除本地缓存的key，所以得想办法通知集群所有节点，删除对应的本地缓存key。<img src="https://cdn.nlark.com/yuque/0/2024/webp/45710781/1719206460942-a23e632f-9c8a-4b8e-9e23-ca904a2e3fee.webp#averageHue=%23fcf8f6&amp;clientId=ue723f105-1fb8-4&amp;from=paste&amp;id=u71948ad8&amp;originHeight=788&amp;originWidth=999&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u52895006-b599-4b27-ad9b-f25aeda1d3c&amp;title=" alt=""> 可以采用消息队列的方式：</p><ol><li>采用Redis本身的Pub/Sub机制，分布式集群的所有节点订阅删除本地缓存频道，删除Redis缓存的节点，同事发布删除本地缓存消息，订阅者们订阅到消息后，删除对应的本地key。但是Redis的发布订阅不是可靠的，不能保证一定删除成功。</li><li>引入专业的消息队列，比如RocketMQ，保证消息的可靠性，但是增加了系统的复杂度。</li><li>设置适当的过期时间兜底，本地缓存可以设置相对短一些的过期时间。</li></ol><h4 id="_17-怎么处理热key" tabindex="-1"><a class="header-anchor" href="#_17-怎么处理热key"><span>17.怎么处理热key？</span></a></h4><p>**什么是热Key？**所谓的热key，就是访问频率比较的key。 比如，热门新闻事件或商品，这类key通常有大流量的访问，对存储这类信息的 Redis来说，是不小的压力。 假如Redis集群部署，热key可能会造成整体流量的不均衡，个别节点出现OPS过大的情况，极端情况下热点key甚至会超过 Redis本身能够承受的OPS。 <strong>怎么处理热key？</strong><img src="https://cdn.nlark.com/yuque/0/2024/webp/45710781/1719206460980-31c78a89-7a0b-45d9-816a-d7c92fd291c8.webp#averageHue=%23fbfaf7&amp;clientId=ue723f105-1fb8-4&amp;from=paste&amp;id=u98e4363a&amp;originHeight=401&amp;originWidth=677&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u7be67a72-fa77-4aec-9a86-fb98b256c17&amp;title=" alt=""> 对热key的处理，最关键的是对热点key的监控，可以从这些端来监控热点key:</p><ol><li>客户端 客户端其实是距离key“最近”的地方，因为Redis命令就是从客户端发出的，例如在客户端设置全局字典（key和调用次数），每次调用Redis命令时，使用这个字典进行记录。</li><li>代理端 像Twemproxy、Codis这些基于代理的Redis分布式架构，所有客户端的请求都是通过代理端完成的，可以在代理端进行收集统计。</li><li>Redis服务端 使用monitor命令统计热点key是很多开发和运维人员首先想到，monitor命令可以监控到Redis执行的所有命令。</li></ol><p>只要监控到了热key，对热key的处理就简单了：</p><ol><li>把热key打散到不同的服务器，降低压⼒</li><li>加⼊⼆级缓存，提前加载热key数据到内存中，如果redis宕机，⾛内存查询</li></ol><h4 id="_18-缓存预热怎么做呢" tabindex="-1"><a class="header-anchor" href="#_18-缓存预热怎么做呢"><span>18.缓存预热怎么做呢？</span></a></h4><p>所谓缓存预热，就是提前把数据库里的数据刷到缓存里，通常有这些方法： 1、直接写个缓存刷新页面或者接口，上线时手动操作 2、数据量不大，可以在项目启动的时候自动进行加载 3、定时任务刷新缓存.</p><h4 id="_19-热点key重建-问题-解决" tabindex="-1"><a class="header-anchor" href="#_19-热点key重建-问题-解决"><span>19.热点key重建？问题？解决？</span></a></h4><p>开发的时候一般使用“缓存+过期时间”的策略，既可以加速数据读写，又保证数据的定期更新，这种模式基本能够满足绝大部分需求。 但是有两个问题如果同时出现，可能就会出现比较大的问题：</p><ul><li>当前key是一个热点key（例如一个热门的娱乐新闻），并发量非常大。</li><li>重建缓存不能在短时间完成，可能是一个复杂计算，例如复杂的 SQL、多次IO、多个依赖等。在缓存失效的瞬间，有大量线程来重建缓存，造成后端负载加大，甚至可能会让应用崩溃。</li></ul><p><strong>怎么处理呢？</strong> 要解决这个问题也不是很复杂，解决问题的要点在于：</p><ul><li>减少重建缓存的次数。</li><li>数据尽可能一致。</li><li>较少的潜在危险。</li></ul><p>所以一般采用如下方式：</p><ol><li>互斥锁（mutex key） 这种方法只允许一个线程重建缓存，其他线程等待重建缓存的线程执行完，重新从缓存获取数据即可。</li><li>永远不过期 “永远不过期”包含两层意思：</li></ol><ul><li>从缓存层面来看，确实没有设置过期时间，所以不会出现热点key过期后产生的问题，也就是“物理”不过期。</li><li>从功能层面来看，为每个value设置一个逻辑过期时间，当发现超过逻辑过期时间后，会使用单独的线程去构建缓存。</li></ul><h4 id="_20-了解bigkey-吗" tabindex="-1"><a class="header-anchor" href="#_20-了解bigkey-吗"><span>20.了解Bigkey 吗？</span></a></h4><blockquote><p>什么是bigkey? 如何解决bigkey?springboot的使用？</p></blockquote><h5 id="_1-什么是bigkey" tabindex="-1"><a class="header-anchor" href="#_1-什么是bigkey"><span>1.什么是BIgKey?</span></a></h5><p><strong>通俗易懂的讲，Big Key就是某个key对应的value很大，占用的redis空间很大，本质上是大value问题。</strong> key往往是程序可以自行设置的，value往往不受程序控制，因此可能导致value很大。 redis中这些Big Key对应的value值很大，在序列化/反序列化过程中花费的时间很大，因此当我们操作Big Key时，通常比较耗时，这就可能导致redis发生阻塞，从而降低redis性能。 BigKey指以Key的大小和Key中成员的数量来综合判定，用几个实际的例子对大Key的特征进行描述：</p><ul><li>Key本身的数据量过大：一个String类型的Key，它的值为5MB</li><li>Key中的成员数过多：一个ZSET类型的Key，它的成员数量为10000个</li><li>Key中成员的数据量过大：一个Hash类型的Key，它的成员数量虽然只有1000个但这些成员的Value值总大小为100MB</li></ul><p><strong>在实际业务中，大Key的判定仍然需要根据Redis的实际使用场景、业务场景来进行综合判断。通常都会以数据大小与成员数量来判定。</strong></p><h5 id="_2-如何解决bigkey" tabindex="-1"><a class="header-anchor" href="#_2-如何解决bigkey"><span>2.如何解决BigKey</span></a></h5><p>Big Key问题指的是在Redis中单个键（Key）对应的值（Value）过大，这可能导致内存使用效率低下，以及影响Redis的性能和响应速度。以下是几种常见的解决方法：</p><p><strong>1. 对大Key进行拆分</strong> 将一个Big Key拆分成多个小Key，每个小Key的成员数量或大小都保持在合理范围内。这样做可以降低单个操作的内存和性能负担。</p><p><strong>实施步骤：</strong></p><ul><li>确定合理的拆分标准，例如每个小Key包含的元素数量或大小。</li><li>重构应用程序逻辑，以支持通过多个小Key进行数据存取。</li></ul><p>** 2. 对大Key进行清理** 定期检查并删除不再需要的大Key，释放内存资源。</p><p>实施步骤：</p><ul><li>使用<code>UNLINK</code>命令逐步删除大Key，避免阻塞Redis主线程。</li><li>监控Key的使用情况，及时清理无用或过期的数据。</li></ul><p><strong>3. 监控Redis的内存和性能指标</strong> 通过监控系统来跟踪Redis的内存使用情况和其他性能指标，以便及时发现潜在的大Key问题。</p><p>实施步骤：</p><ul><li>设置内存使用率和增长速度的警告阈值。</li><li>使用Redis的监控工具，如<code>INFO</code>命令或第三方监控系统。</li></ul><p>** 4. 定期清理失效数据** 对于不断增长但具有时效性的数据，定期清理可以防止大量失效数据的堆积。</p><p>实施步骤：</p><ul><li>利用Redis的过期策略，如设置Key的过期时间。</li><li>通过定时任务清理那些不再需要或过期的数据。</li></ul><p>** 5. 压缩value** 使用序列化和压缩技术减小value的大小，但要注意这可能会增加CPU的负担。</p><p>实施步骤：</p><ul><li>选择合适的序列化格式，如JSON、MessagePack等。</li><li>应用压缩算法，如gzip，但要权衡压缩与解压的性能开销。</li></ul><p>** 6. 优化数据结构** 根据数据的使用模式优化数据结构，例如使用更适合的数据类型或结构来减少内存占用。</p><p>实施步骤：</p><ul><li>分析数据访问模式，选择最合适的Redis数据类型。</li><li>重构数据模型以减少冗余和提高内存效率。</li></ul><p><strong>7. 使用更高效的数据编码</strong> 利用Redis提供的不同类型的内部编码方式，如使用<code>intset</code>代替<code>hashtable</code>存储小整数集合。</p><p>实施步骤：</p><ul><li>根据数据特性选择合适的内部编码。</li><li>调整Redis配置以优化特定类型的数据存储。</li></ul><p><strong>8. 避免过度使用持久化</strong> 过度的持久化操作可能会影响性能，特别是在处理大Key时。</p><p>实施步骤：</p><ul><li>根据业务需求调整RDB和AOF的持久化策略。</li><li>考虑在低峰时段进行持久化操作。</li></ul><p>** 结论** 解决Big Key问题需要综合考虑数据模型、访问模式、性能监控和系统配置等多个方面。通过上述方法，可以有效地管理和减小Big Key带来的影响，从而提高Redis的整体性能和稳定性。</p><h5 id="_3-来个redis-的string-分析" tabindex="-1"><a class="header-anchor" href="#_3-来个redis-的string-分析"><span>3.来个Redis 的String 分析</span></a></h5><p>Redis string 的命令 只能一次设置/查询一个键值对，这样虽然简单，但是效率不高。 为了提高命令的执行效率， Redis 提供了可以批量操作多个字符串的读写命令 MSET/MGET（“M”代表“Many”）， 它们允许你一次性设置或查询多个键值对，这样就有效地减少了网络耗时。</p><p>Redis 使用标准 C 语言编写，但在存储字符时，Redis 并未使用 C 语言的字符类型， 为了存储字符串，Redis 自定义了一个属于特殊结构 SDS（Simple Dynamic String）即简单动态字符串）， SDS 是一个可以修改的内部结构，非常类似于 Java 的 ArrayList。</p><p><strong>1.SDS动态字符串</strong> SDS 的结构定义如下：</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre class="language-java"><code><span class="line">struct sdshdr<span class="token punctuation">{</span></span>
<span class="line">     <span class="token comment">//记录buf数组中已使用字符的数量，等于 SDS 保存字符串的长度</span></span>
<span class="line">     <span class="token keyword">int</span> len<span class="token punctuation">;</span></span>
<span class="line">     <span class="token comment">//记录 buf 数组中未使用的字符数量</span></span>
<span class="line">     <span class="token keyword">int</span> free<span class="token punctuation">;</span></span>
<span class="line">     <span class="token comment">//字符数组，用于保存字符串</span></span>
<span class="line">     <span class="token keyword">char</span> buf<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>从上述结构体可以看出，Redis string 将字符串存储到字符类型的buf[] 、len、free</p><p><strong>2.分配冗余空间</strong> string 采用了预先分配冗余空间的方式来减少内存的频繁分配，如下图所示： <img src="https://cdn.nlark.com/yuque/0/2024/gif/45710781/1719195274300-29895fe4-061e-4c7b-b059-d0bb197c766e.gif#averageHue=%23fdf8f1&amp;clientId=u29bbc1e3-5b41-4&amp;from=paste&amp;id=ufe716ce5&amp;originHeight=259&amp;originWidth=545&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=ub74ba477-ffb6-4531-829a-ffbf5607173&amp;title=" alt=""> 如图 所示，Redis 每次给 string 分配的空间都要大于字符串实际占用的空间，这样就在一定程度上提升了 Redis string 存储的效率，比如当字符串长度变大时，无需再重新申请内存空间。 当字符串所占空间小于 1MB 时，Redis 对字符串存储空间的扩容是以成倍的方式增加的；而当所占空间超过 1MB 时，每次扩容只增加 1MB。Redis 字符串允许的最大值字节数是 512 MB。</p><h5 id="_4-springboot-bigkey的scan扫描实操" tabindex="-1"><a class="header-anchor" href="#_4-springboot-bigkey的scan扫描实操"><span>4.SpringBoot BigKey的scan扫描实操</span></a></h5><p>SpringBoot 应用中，可是经过用scan，咱们就能够指定有共性的key，并指定一次性查询条件。 演示的代码如下：</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text" data-title="text"><pre class="language-text"><code><span class="line">@Autowired</span>
<span class="line">private StringRedisTemplate redisTemplate;</span>
<span class="line"></span>
<span class="line">public void scanForBigkeys() {</span>
<span class="line">    long cursor = ScanOptions.SCAN_POINTER_START;</span>
<span class="line">    Set&lt;String&gt; bigkeys = new HashSet&lt;&gt;();</span>
<span class="line">    do {</span>
<span class="line">        ScanOptions options = ScanOptions.scanOptions()</span>
<span class="line">                .match(&quot;your_key_pattern*&quot;) // 指定key的模式</span>
<span class="line">                .count(1000) // 每次迭代扫描的键的数量</span>
<span class="line">                .build();</span>
<span class="line">        Cursor&lt;String&gt; scanCursor = redisTemplate.executeWithStickyConnection(</span>
<span class="line">            (RedisConnection connection, Object[] args) -&gt; connection.scan(cursor, (ScanOptions) args[0])</span>
<span class="line">        );</span>
<span class="line">        </span>
<span class="line">        while (scanCursor.hasNext()) {</span>
<span class="line">            String key = scanCursor.next();</span>
<span class="line">            long sizeInBytes = redisTemplate.getConnectionFactory().getConnection().strlen(key);</span>
<span class="line">            if (sizeInBytes &gt; YOUR_BIGKEY_SIZE_THRESHOLD) {</span>
<span class="line">                bigkeys.add(key);</span>
<span class="line">            }</span>
<span class="line">        }</span>
<span class="line">        cursor = scanCursor.getPos();</span>
<span class="line">    } while (!cursor.equals(0L));</span>
<span class="line">    </span>
<span class="line">    // 处理发现的bigkeys</span>
<span class="line">    if (!bigkeys.isEmpty()) {</span>
<span class="line">        sendAlert(bigkeys);</span>
<span class="line">    }</span>
<span class="line">}</span>
<span class="line"></span>
<span class="line">private void sendAlert(Set&lt;String&gt; bigkeys) {</span>
<span class="line">    // 发送邮件或钉钉消息</span>
<span class="line">}</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这里例子中，是 以 大于 50个字节，就计算为 bigkey. 这个阈值，仅仅是为了演示方便，生产场景，可以设置一个大的阈值，比如，一个String类型的Key，它的阈值为5MB</p><p><strong>执行的结果</strong> 启动应用，可以得到执行的结果 <img src="https://cdn.nlark.com/yuque/0/2024/png/45710781/1719195422522-30fcfa33-4307-47ce-887b-babeb23837f1.png#averageHue=%23a1a7af&amp;clientId=u29bbc1e3-5b41-4&amp;from=paste&amp;id=u7ba28aed&amp;originHeight=850&amp;originWidth=1517&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u8e1db7a9-9b37-49e0-af51-80f34f893f3&amp;title=" alt=""> 实验完美成功 生产场景的bigkey 扫描 结合scan + 定时任务的方式， 在 吞吐量的低峰期，进行扫描 发现了bigkey， 可以及时的进行 运维 告警， 发送 邮件通知或者 钉钉企业信息</p><p><strong>类似场景，对大量key进行扫描的cluster</strong> 在线上有时候，须要对大量key进行扫描（如删除）操做，有几个风险点：</p><ol><li>一次性查询所指定的key, 如果是使用keys，数量较大可能形成redis服务卡顿，Redis是单线程程序，顺序执行全部指令，其它指令必须等到当前的 keys 指令执行完了才能够继续。</li><li>从海量的 key 中找出知足特定前缀的 key 上面的场景中，都可以用scan，咱们就能够指定有共性的key，并指定一次性查询条件。</li></ol><p><strong>要点是：使用SCAN命令扫描key替代KEYS避免redis服务器阻塞，无坑！</strong></p><h4 id="_21-说说redis-架构" tabindex="-1"><a class="header-anchor" href="#_21-说说redis-架构"><span>21.说说redis 架构</span></a></h4><p><strong>1.Redis单机：</strong> 首先，在使用最简单的单机版 Redis 时，我们遇到了 Redis 故障宕机后数据无法恢复的问题，因此我们引入了「数据持久化」，将内存中的数据保存到磁盘上，以便 Redis 重启后能快速恢复数据。 **2.加入AOF/RDB: **在进行数据持久化时，我们面临如何更高效地将数据保存到磁盘的问题。后来我们发现 Redis 提供了 RDB 和 AOF 两种方案，分别对应数据快照和实时命令记录。当对数据完整性要求不高时，可以选择 RDB 持久化方案；如果对数据完整性要求较高，可以选择 AOF 持久化方案。 **3.混合使用：**但是我们又发现，AOF 文件体积会随着时间增长变得越来越大，此时我们想到的优化方案是，使用 AOF rewrite 的方式对其进行瘦身，减小文件体积，再后来，我们发现可以结合 RDB 和 AOF 各自的优势，在 AOF rewrite 时使用两者结合的「混合持久化」方式，又进一步减小了 AOF 文件体积。 **4.加上副本：**接着，我们发现虽然可以通过数据恢复的方式还原数据，但恢复数据仍需要花费时间，这意味着业务应用仍会受到影响。我们进一步优化，采用「多副本」的方案，让多个实例保持实时同步，当一个实例故障时，可以手动把其他实例提升上来继续提供服务。 **5.哨兵模式：**但是这样也有问题，手动提升实例上来，需要人工介入，人工介入操作也需要时间，我们开始寻找方法使这个流程自动化，因此我们引入了「哨兵」集群。哨兵集群通过互相协商的方式，发现故障节点，并可以自动完成切换，从而大幅降低对业务应用的影响。 **6.分片集群：**最后，我们将关注点放在如何支持更大的写流量上，因此引入了「分片集群」来解决这个问题，让多个 Redis 实例分担写压力。面对更大的流量，我们还可以添加新的实例进行横向扩展，进一步提高集群性能。</p><p>通过这些步骤，我们的 Redis 集群能够长期稳定、高性能地为我们的业务提供服务。 在架构演进的过程中， 围绕着「架构设计」的核心思想：</p><ul><li><strong>高性能</strong>：读写分离、分片集群</li><li><strong>高可用</strong>：数据持久化、多副本、故障自动切换</li><li><strong>易扩展</strong>：分片集群、横向扩展</li><li><strong>高可靠</strong>： 写后日志、数据快照</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2024/png/45710781/1719194197164-f458d014-98cf-451e-b1cd-798dbefbd75a.png#averageHue=%23fdfcfb&amp;clientId=u7b9a971d-9265-4&amp;from=paste&amp;height=649&amp;id=uc85ba125&amp;originHeight=649&amp;originWidth=830&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=109632&amp;status=done&amp;style=none&amp;taskId=udd0735e7-9ff1-4839-8bbf-992dc04abaf&amp;title=&amp;width=830" alt="image.png"> 在进行软件架构设计时，您面临的场景是发现问题、分析问题、解决问题，逐步优化和升级您的架构，最终在性能和可靠性方面达到平衡。 尽管各种软件层出不穷，但架构设计的理念不会改变，希望您真正吸收的是这些思想，这样才能做到以不变应万变。</p><h4 id="_22-redis-优化-了解不-你做过哪些" tabindex="-1"><a class="header-anchor" href="#_22-redis-优化-了解不-你做过哪些"><span>22.redis 优化 了解不，你做过哪些？</span></a></h4><p>Redis 是一个高效的内存数据库，但为了充分发挥其性能和可靠性，进行合理的优化是非常必要的。以下是对 Redis 进行优化的一些关键建议和措施：</p><h5 id="_1-使用短的-key-和精简的-value" tabindex="-1"><a class="header-anchor" href="#_1-使用短的-key-和精简的-value"><span>1. 使用短的 Key 和精简的 Value</span></a></h5><ul><li><strong>短 Key</strong>：减少内存占用，缩短哈希表查找时间。虽然要保持 Key 的可读性，但尽量缩短长度。</li><li><strong>精简 Value</strong>：对于可以使用数字或短字符串表示的数据，如性别、状态等，使用数字代替字符串。</li></ul><h5 id="_2-避免存储过大的数据" tabindex="-1"><a class="header-anchor" href="#_2-避免存储过大的数据"><span>2. 避免存储过大的数据</span></a></h5><ul><li><strong>大数据分片</strong>：避免单个 Key 存储过多数据，可以使用分片技术，将数据分散到多个 Key 中存储。</li></ul><h5 id="_3-慎用复杂度高的命令" tabindex="-1"><a class="header-anchor" href="#_3-慎用复杂度高的命令"><span>3. 慎用复杂度高的命令</span></a></h5><ul><li><strong>Keys *</strong>：尽量避免使用 keys * 这种复杂度为 O(n) 的命令。替代方法是使用 SCAN 命令进行迭代查询。</li><li><strong>其他复杂命令</strong>：参考 <a href="%5Bhttps://redis.io/commands">Redis 命令复杂度</a>](https://redis.io/commands)) 文档，尽量避免使用高复杂度命令。</li></ul><h5 id="_4-数据压缩" tabindex="-1"><a class="header-anchor" href="#_4-数据压缩"><span>4. 数据压缩</span></a></h5><ul><li><strong>内部编码</strong>：Redis 对不同的数据类型有不同的编码方式，自动根据情况调整。可以通过配置参数进行调优，比如 <code>hash-max-ziplist-entries</code> 和 <code>hash-max-ziplist-value</code>。</li></ul><h5 id="_5-设置-key-的有效期" tabindex="-1"><a class="header-anchor" href="#_5-设置-key-的有效期"><span>5. 设置 Key 的有效期</span></a></h5><ul><li><strong>过期时间</strong>：为临时数据设置过期时间，减少内存占用。避免大量数据同时过期，可以使用不同的过期时间。</li></ul><h5 id="_6-内存管理策略" tabindex="-1"><a class="header-anchor" href="#_6-内存管理策略"><span>6. 内存管理策略</span></a></h5><ul><li><strong>回收策略</strong>：根据需求选择合适的内存回收策略。常用策略包括： <ul><li><code>volatile-lru</code>：对设置了过期时间的 Key 进行 LRU 回收。</li><li><code>allkeys-lru</code>：对所有 Key 进行 LRU 回收。</li><li>其他策略：<code>volatile-random</code>、<code>allkeys-random</code>、<code>volatile-ttl</code>、<code>noeviction</code>。</li></ul></li></ul><h5 id="_7-使用连接池" tabindex="-1"><a class="header-anchor" href="#_7-使用连接池"><span>7. 使用连接池</span></a></h5><ul><li><strong>连接池</strong>：减少连接创建和释放的开销，提高并发处理能力。</li></ul><h5 id="_8-内存优化操作" tabindex="-1"><a class="header-anchor" href="#_8-内存优化操作"><span>8. 内存优化操作</span></a></h5><ul><li><strong>Bit 操作</strong>：使用 GETRANGE、SETRANGE、GETBIT、SETBIT 进行位级别操作，减少内存占用。</li><li><strong>Hash 操作</strong>：尽量使用 Hash 结构进行存储，特别是在有多个字段需要存储时。</li></ul><h5 id="_9-关闭持久化-视业务需求" tabindex="-1"><a class="header-anchor" href="#_9-关闭持久化-视业务需求"><span>9. 关闭持久化（视业务需求）</span></a></h5><ul><li><strong>无持久化</strong>：在不需要数据持久化的场景下，可以关闭 RDB 和 AOF，获得更高性能。</li></ul><h5 id="_10-使用管道-pipeline" tabindex="-1"><a class="header-anchor" href="#_10-使用管道-pipeline"><span>10. 使用管道（Pipeline）</span></a></h5><ul><li><strong>批量操作</strong>：使用管道一次性发送多条命令，减少网络开销和 RTT（Round Trip Time）。<div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre class="language-java"><code><span class="line"><span class="token annotation punctuation">@Test</span></span>
<span class="line"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">usePipeline</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token class-name">Jedis</span> jedis <span class="token operator">=</span> <span class="token class-name">JedisUtil</span><span class="token punctuation">.</span><span class="token function">getJedis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token keyword">long</span> start_time <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token class-name">Pipeline</span> pipelined <span class="token operator">=</span> jedis<span class="token punctuation">.</span><span class="token function">pipelined</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10000</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        pipelined<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token string">&quot;cc_&quot;</span> <span class="token operator">+</span> i<span class="token punctuation">,</span> i <span class="token operator">+</span> <span class="token string">&quot;&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line">    pipelined<span class="token punctuation">.</span><span class="token function">sync</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> start_time<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul><h5 id="_11-配置系统参数" tabindex="-1"><a class="header-anchor" href="#_11-配置系统参数"><span>11. 配置系统参数</span></a></h5><ul><li><strong>TCP Backlog</strong>：增大 /proc/sys/net/core/somaxconn 的值。<div class="language-bash line-numbers-mode" data-highlighter="prismjs" data-ext="sh" data-title="sh"><pre class="language-bash"><code><span class="line"><span class="token builtin class-name">echo</span> <span class="token number">511</span> <span class="token operator">&gt;</span> /proc/sys/net/core/somaxconn</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div></li><li><strong>内存分配策略</strong>：设置 vm.overcommit_memory = 1。<div class="language-bash line-numbers-mode" data-highlighter="prismjs" data-ext="sh" data-title="sh"><pre class="language-bash"><code><span class="line"><span class="token builtin class-name">echo</span> <span class="token string">&#39;vm.overcommit_memory = 1&#39;</span> <span class="token operator">&gt;&gt;</span> /etc/sysctl.conf</span>
<span class="line"><span class="token function">sysctl</span> <span class="token parameter variable">-p</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div></li><li><strong>关闭透明大页（THP）</strong>：<div class="language-bash line-numbers-mode" data-highlighter="prismjs" data-ext="sh" data-title="sh"><pre class="language-bash"><code><span class="line"><span class="token builtin class-name">echo</span> never <span class="token operator">&gt;</span> /sys/kernel/mm/transparent_hugepage/enabled</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div></li></ul><h5 id="_12-性能分析" tabindex="-1"><a class="header-anchor" href="#_12-性能分析"><span>12. 性能分析</span></a></h5><ul><li><strong>慢日志</strong>：<div class="language-bash line-numbers-mode" data-highlighter="prismjs" data-ext="sh" data-title="sh"><pre class="language-bash"><code><span class="line">CONFIG SET slowlog-log-slower-than <span class="token number">10000</span></span>
<span class="line">CONFIG SET slowlog-max-len <span class="token number">1000</span></span>
<span class="line">SLOWLOG GET <span class="token number">10</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><strong>基准测试</strong>：<div class="language-bash line-numbers-mode" data-highlighter="prismjs" data-ext="sh" data-title="sh"><pre class="language-bash"><code><span class="line">redis-cli --intrinsic-latency <span class="token number">120</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div></li></ul><h5 id="_13-其他优化措施" tabindex="-1"><a class="header-anchor" href="#_13-其他优化措施"><span>13. 其他优化措施</span></a></h5><ul><li><strong>避免 Big Key</strong>：对于大 Key 采用异步删除，防止阻塞主线程。</li><li><strong>合理配置 AOF</strong>：根据业务需要调整 AOF 的同步策略，减少 IO 压力。</li><li><strong>控制内存占用</strong>：避免 Redis 使用 Swap，必要时增加物理内存。</li><li><strong>多核 CPU 优化</strong>：绑定 Redis 进程到物理 CPU 核，提高处理能力。</li><li><strong>集群配置</strong>：在使用主从集群时，控制每个实例的数据量，避免因复制带来的性能问题。</li></ul><p>通过这些优化措施，可以显著提升 Redis 的性能和可靠性，确保在高并发和大数据量的场景下仍然能够高效运行。</p></div><!--[--><!--]--></div><footer class="vp-page-meta"><div class="vp-meta-item edit-link"><a class="auto-link external-link label" href="https://github.com/leaderrSong/min/edit/main/js/6.Redis.md" aria-label="Edit this page" rel="noopener noreferrer" target="_blank"><!--[--><svg class="edit-icon" viewbox="0 0 1024 1024"><g fill="currentColor"><path d="M430.818 653.65a60.46 60.46 0 0 1-50.96-93.281l71.69-114.012 7.773-10.365L816.038 80.138A60.46 60.46 0 0 1 859.225 62a60.46 60.46 0 0 1 43.186 18.138l43.186 43.186a60.46 60.46 0 0 1 0 86.373L588.879 565.55l-8.637 8.637-117.466 68.234a60.46 60.46 0 0 1-31.958 11.229z"></path><path d="M728.802 962H252.891A190.883 190.883 0 0 1 62.008 771.98V296.934a190.883 190.883 0 0 1 190.883-192.61h267.754a60.46 60.46 0 0 1 0 120.92H252.891a69.962 69.962 0 0 0-69.098 69.099V771.98a69.962 69.962 0 0 0 69.098 69.098h475.911A69.962 69.962 0 0 0 797.9 771.98V503.363a60.46 60.46 0 1 1 120.922 0V771.98A190.883 190.883 0 0 1 728.802 962z"></path></g></svg><!--]-->Edit this page<!----></a></div><div class="vp-meta-item git-info"><div class="vp-meta-item last-updated"><span class="meta-item-label">Last Updated: </span><!----></div><div class="vp-meta-item contributors"><span class="meta-item-label">Contributors: </span><span class="meta-item-info"><!--[--><!--[--><span class="contributor" title="email: 3297943361@qq.com">swp</span><!----><!--]--><!--]--></span></div></div></footer><nav class="vp-page-nav" aria-label="page navigation"><a class="route-link auto-link prev" href="/js/5.line.html" aria-label="5.多线程"><div class="hint"><span class="arrow left"></span> Prev</div><div class="link"><span>5.多线程</span></div></a><a class="route-link auto-link next" href="/js/7.serve.html" aria-label="7.微服务架构"><div class="hint">Next <span class="arrow right"></span></div><div class="link"><span>7.微服务架构</span></div></a></nav><!--[--><!--]--></main><!--]--></div><!--[--><!----><!--]--><!--]--></div>
    <script src="/assets/js/runtime~app.bdc11503.js" defer></script><script src="/assets/js/639.c6a90640.js" defer></script><script src="/assets/js/app.69d07200.js" defer></script>
  </body>
</html>
